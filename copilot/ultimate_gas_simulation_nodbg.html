<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Ultimate Ideal Gas Simulation (Dynamic Graph Y Axis)</title>
  <meta name="viewport" content="width=1200, initial-scale=1.0">
  <style>
    body { background: #111; color: #fff; font-family: Arial, sans-serif; margin: 0; padding: 0;}
    .container { max-width: 1500px; margin: 0 auto;}
    .controls { display: flex; flex-wrap: wrap; gap: 20px; align-items: center; margin: 20px 0; }
    .controls label { font-size: 14px; }
    .controls input[type="range"] { width: 120px; }
    .stats, .temp-display { display: flex; gap: 24px; margin-bottom: 8px; }
    .canvas-row { display: flex; gap: 24px; }
    canvas { background: black; border: 2px solid #333; border-radius: 12px;}
    .btn { background: #333; color: #fff; border: none; border-radius: 5px; padding: 8px 20px; cursor: pointer; font-size: 14px;}
    .btn:hover { background: #555;}
    .graph-title { text-align: center; font-size: 13px; }
    
  </style>
</head>
<body>
<div class="container">
  <h1>Ultimate Ideal Gas Simulation <span style="font-size:16px;color:#ff0;">[Collision sim]</span></h1>
  
  <!-- Controls -->
  <div class="controls">
    <label>Particles/Box: <input id="nRange" type="range" min="10" max="17000" value="500"><span id="nLabel">500</span></label>
    <label>Temp Left: <input id="tLRange" type="range" min="0" max="1200" value="300"><span id="tLLabel">300</span></label>
    <label>Temp Right: <input id="tRRange" type="range" min="0" max="1200" value="100"><span id="tRLabel">100</span></label>
    <label>Radius: <input id="rRange" type="range" min="1" max="8" value="3"><span id="rLabel">3</span></label>
    <label>Pipe Height: <input id="pipeRange" type="range" min="30" max="600" value="100"><span id="pipeLabel">100</span></label>
    <button class="btn" id="resetBtn">Reset</button>
    <button class="btn" id="pauseBtn">Pause</button>
    <button class="btn" id="openWallBtn">Open Pipe</button>
  </div>
  
  <!-- Debug Info -->
  
  <!-- Stats -->
  <div class="temp-display">
    <div style="color:#ffa;">Left Temp: <span id="leftTemp">0</span></div>
    <div style="color:#aaf;">Right Temp: <span id="rightTemp">0</span></div>
  </div>
  <div class="stats">
    <div>Total Particles: <span id="totalParticles">0</span></div>
    <div>Collisions/sec: <span id="collisionRate">0</span></div>
    <div>FPS: <span id="fps">0</span></div>
  </div>
  
  <!-- Canvases -->
  <div class="canvas-row">
    <canvas id="simCanvas" width="1200" height="600"></canvas>
    <div>
      <div class="graph-title" style="color:#ffa;">Left Box Temperature</div>
      <canvas id="leftGraph" width="200" height="100"></canvas>
      <div class="graph-title" style="color:#aaf;">Right Box Temperature</div>
      <canvas id="rightGraph" width="200" height="100"></canvas>
    </div>
  </div>
</div>

<script>
/* --- UI Elements --- */
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const leftGraph = document.getElementById('leftGraph').getContext('2d');
const rightGraph = document.getElementById('rightGraph').getContext('2d');
const nRange = document.getElementById('nRange');
const tLRange = document.getElementById('tLRange');
const tRRange = document.getElementById('tRRange');
const rRange = document.getElementById('rRange');
const pipeRange = document.getElementById('pipeRange');
const nLabel = document.getElementById('nLabel');
const tLLabel = document.getElementById('tLLabel');
const tRLabel = document.getElementById('tRLabel');
const rLabel = document.getElementById('rLabel');
const pipeLabel = document.getElementById('pipeLabel');
const resetBtn = document.getElementById('resetBtn');
const pauseBtn = document.getElementById('pauseBtn');
const openWallBtn = document.getElementById('openWallBtn');
const leftTempDisplay = document.getElementById('leftTemp');
const rightTempDisplay = document.getElementById('rightTemp');
const totalParticlesDisplay = document.getElementById('totalParticles');
const collisionRateDisplay = document.getElementById('collisionRate');
const fpsDisplay = document.getElementById('fps');

/* --- Config/State --- */
let paused = false, wallOpen = false;
let particles = [];
let pipeHeight = parseInt(pipeRange.value);
let collisionCount = 0, lastCollisionCount = 0, frameCount = 0, lastFpsTime = 0;
let leftTempHistory = [], rightTempHistory = [];
const maxGraphPoints = 100;
let graphUpdateCounter = 0;
const TEMP_SPEED_FACTOR = 0.025; // Don't change speed factor!
const leftBox = {x:0, y:0, w:canvas.width/2, h:canvas.height};
const rightBox = {x:canvas.width/2, y:0, w:canvas.width/2, h:canvas.height};

/* --- Particle Class --- */
class Particle {
  constructor(x, y, vx, vy, r, m=1) {
    this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.r = r; this.m = m;
  }
  update() {
    const maxStep = Math.min(this.r, 0.5);
    const steps = Math.ceil(Math.max(Math.abs(this.vx), Math.abs(this.vy)) / maxStep);
    const dt = 1/steps;
    for(let s=0;s<steps;s++) {
      this.x += this.vx*dt;
      this.y += this.vy*dt;
      if(this.x-this.r<0) { this.x=this.r; this.vx*=-1; }
      if(this.x+this.r>canvas.width) { this.x=canvas.width-this.r; this.vx*=-1; }
      if(this.y-this.r<0) { this.y=this.r; this.vy*=-1; }
      if(this.y+this.r>canvas.height) { this.y=canvas.height-this.r; this.vy*=-1; }
      if(this.x+this.r>leftBox.w && this.x-this.r<leftBox.w) {
        const withinPipe = (this.y>(canvas.height-pipeHeight)/2 && this.y<(canvas.height+pipeHeight)/2);
        if(!wallOpen || !withinPipe) {
          if(this.x<leftBox.w) { this.x=leftBox.w-this.r; this.vx*=-1; }
          else { this.x=leftBox.w+this.r; this.vx*=-1; }
        }
      }
    }
  }
  draw() {
    const speed = Math.sqrt(this.vx*this.vx+this.vy*this.vy);
    const hue = 240-Math.min(speed*600,240);
    ctx.fillStyle = `hsl(${hue},100%,50%)`;
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.r,0,2*Math.PI);
    ctx.fill();
  }
}

/* --- Sweep and Prune Collision Detection --- */
function sweepAndPrune(particles) {
  let arr = particles.slice().sort((a,b)=>a.x-b.x);
  for(let i=0;i<arr.length;i++) {
    let a = arr[i];
    for(let j=i+1;j<arr.length && arr[j].x - a.x <= a.r + arr[j].r;j++) {
      let b = arr[j];
      if(Math.abs(b.y-a.y) < a.r+b.r) {
        let dx = b.x-a.x, dy = b.y-a.y;
        let dist = Math.hypot(dx,dy);
        if(dist>0 && dist<a.r+b.r) {
          let nx=dx/dist, ny=dy/dist;
          let kx = a.vx-b.vx, ky = a.vy-b.vy;
          let p = 2*(nx*kx+ny*ky)/(a.m+b.m);
          a.vx -= p*b.m*nx; a.vy -= p*b.m*ny;
          b.vx += p*a.m*nx; b.vy += p*a.m*ny;
          let overlap = (a.r+b.r)-dist;
          a.x -= nx*overlap/2; a.y -= ny*overlap/2;
          b.x += nx*overlap/2; b.y += ny*overlap/2;
          collisionCount++;
        }
      }
    }
  }
}

/* --- Temperature/Stats --- */
function getTemperature(boxIndex) {
  let sumKE=0, count=0;
  for(let p of particles) {
    if((boxIndex===0 && p.x<leftBox.w)||(boxIndex===1 && p.x>rightBox.x)) {
      sumKE += 0.5*p.m*(p.vx*p.vx+p.vy*p.vy); count++;
    }
  }
  return count ? (2*sumKE)/count : 0;
}
function tempToRMS(T) { return Math.sqrt(Math.max(0,T)) * TEMP_SPEED_FACTOR; }
function currentRMSforBox(boxIndex) {
  let sumSq=0,count=0;
  for(let p of particles) {
    const inLeft=p.x<leftBox.w;
    if((boxIndex===0&&inLeft)||(boxIndex===1&&!inLeft)) {
      sumSq+=p.vx*p.vx+p.vy*p.vy; count++;
    }
  }
  return count?Math.sqrt(sumSq/(2*count)):0;
}
function setBoxTemperature(boxIndex, targetT) {
    const targetRMS = tempToRMS(targetT);
    const currentRMS = currentRMSforBox(boxIndex);

    for (let p of particles) {
        const inLeft = p.x < leftBox.w;
        if ((boxIndex === 0 && inLeft) || (boxIndex === 1 && !inLeft)) {
            if (currentRMS <= 1e-6 || isNaN(currentRMS)) {
                const angle = Math.random() * 2 * Math.PI;
                p.vx = targetRMS * Math.cos(angle);
                p.vy = targetRMS * Math.sin(angle);
            } else {
                const scale = targetRMS / currentRMS;
                p.vx *= scale;
                p.vy *= scale;
            }
        }
    }
}

/* --- Dynamic Y Axis Graph Drawing --- */
function drawGraph(ctx, data, color) {
    // Compute min/max in buffer, pad for headroom
    let min = Math.min(...data);
    let max = Math.max(...data);
    if (min === max) { max = min + 1; } // Prevent divide-by-zero

    // For visual clarity: pad min/max by 10%
    let range = max - min;
    let yMin = Math.max(0, min - 0.1 * range);
    let yMax = max + 0.1 * range;
    if (yMax === yMin) yMax = yMin + 1;

    const width = ctx.canvas.width, height = ctx.canvas.height;
    ctx.clearRect(0, 0, width, height);

    // Draw grid
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 4; i++) {
        let y = (i / 4) * height;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
    }

    // Draw labels (dynamic)
    ctx.fillStyle = "#888";
    ctx.font = '10px Arial';
    ctx.textAlign = "left";
    for (let i = 0; i <= 4; i++) {
        let y = (i / 4) * height;
        let temp = yMax - ((y / height) * (yMax - yMin));
        ctx.fillText(temp.toFixed(3), 2, y + 10);
    }

    // Draw temperature line
    if (data.length > 1) {
        ctx.strokeStyle = color;
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        for (let i = 0; i < data.length; i++) {
            const x = (i / (data.length - 1)) * width;
            const y = height - ((data[i] - yMin) / (yMax - yMin)) * height;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
    }
    // Draw latest value
    if (data.length > 0) {
        ctx.fillStyle = color;
        ctx.font = '12px Arial';
        ctx.textAlign = 'right';
        ctx.fillText(`${data[data.length - 1].toFixed(3)}K`, width - 5, 15);
    }
    // Draw debug info (min/max/avg)
    if (data.length > 0) {
        const avg = data.reduce((a,b)=>a+b,0)/data.length;
        ctx.fillStyle = "#fff";
        ctx.font = '10px monospace';
        ctx.textAlign = 'left';
        ctx.fillText(`min:${min.toFixed(3)} max:${max.toFixed(3)} avg:${avg.toFixed(3)}`, 2, height-2);
    }
}

function updateGraphs(leftTemp, rightTemp) {
  graphUpdateCounter++;
  leftTempHistory.push(leftTemp);
  rightTempHistory.push(rightTemp);
  if(leftTempHistory.length>maxGraphPoints) leftTempHistory.shift();
  if(rightTempHistory.length>maxGraphPoints) rightTempHistory.shift();
  drawGraph(leftGraph, leftTempHistory, "#ffa");
  drawGraph(rightGraph, rightTempHistory, "#aaf");
}

/* --- Simulation Loop --- */
function step(currentTime) {
  if(!paused) {
    for(let p of particles) p.update();
    sweepAndPrune(particles);
  }
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.strokeStyle="#fff"; ctx.lineWidth=3;
  ctx.beginPath();
  ctx.moveTo(leftBox.w,0); ctx.lineTo(leftBox.w,(canvas.height-pipeHeight)/2);
  ctx.moveTo(leftBox.w,(canvas.height+pipeHeight)/2); ctx.lineTo(leftBox.w,canvas.height);
  ctx.stroke();
  for(let p of particles) p.draw();

  // Calculate real box temperatures from particle velocities
  const leftT = getTemperature(0);
  const rightT = getTemperature(1);

  // Stats UI
  leftTempDisplay.textContent = leftT.toFixed(3);
  rightTempDisplay.textContent = rightT.toFixed(3);
  totalParticlesDisplay.textContent = particles.length;

  // Update Graphs
  updateGraphs(leftT, rightT);

  // --- Debug Info Overlay ---
  // Print to console every 10th frame for diagnosis
  if (frameCount % 10 === 0) {  }
  // Analyze graph operation and show in debugBox
  frameCount++;
  if(!lastFpsTime) lastFpsTime=currentTime;
  if(currentTime-lastFpsTime>1000) {
    fpsDisplay.textContent = frameCount;
    collisionRateDisplay.textContent = collisionCount-lastCollisionCount;
    lastCollisionCount = collisionCount;
    frameCount=0;
    lastFpsTime=currentTime;
  }
  requestAnimationFrame(step);
}

/* --- Setup/Reset --- */
function createParticles() {
  particles=[];
  const n = parseInt(nRange.value);
  const r = parseInt(rRange.value);
  for(let i=0;i<n;i++) {
    const speed = tempToRMS(parseFloat(tLRange.value));
    const angle = Math.random()*2*Math.PI;
    const x = Math.random()*(leftBox.w-2*r)+r;
    const y = Math.random()*(leftBox.h-2*r)+r;
    particles.push(new Particle(x,y,speed*Math.cos(angle),speed*Math.sin(angle),r));
  }
  for(let i=0;i<n;i++) {
    const speed = tempToRMS(parseFloat(tRRange.value));
    const angle = Math.random()*2*Math.PI;
    const x = Math.random()*(rightBox.w-2*r)+rightBox.x+r;
    const y = Math.random()*(rightBox.h-2*r)+r;
    particles.push(new Particle(x,y,speed*Math.cos(angle),speed*Math.sin(angle),r));
  }
  leftTempHistory=[]; rightTempHistory=[];
  collisionCount=0; lastCollisionCount=0; frameCount=0; lastFpsTime=0;
}

/* --- Event Listeners --- */
nRange.oninput = ()=>{ nLabel.textContent = nRange.value; };
tLRange.oninput = ()=>{ tLLabel.textContent = tLRange.value; setBoxTemperature(0,Number(tLRange.value)); };
tRRange.oninput = ()=>{ tRLabel.textContent = tRRange.value; setBoxTemperature(1,Number(tRRange.value)); };
rRange.oninput = ()=>{ rLabel.textContent = rRange.value; };
pipeRange.oninput = ()=>{ pipeLabel.textContent = pipeRange.value; pipeHeight=parseInt(pipeRange.value); };
resetBtn.onclick = ()=>{ createParticles(); };
pauseBtn.onclick = ()=>{ paused=!paused; pauseBtn.textContent=paused?'Resume':'Pause'; };
openWallBtn.onclick = ()=>{ wallOpen=!wallOpen; openWallBtn.textContent=wallOpen?'Close Pipe':'Open Pipe'; };

/* --- Init --- */
createParticles();
step();
</script>
</body>
</html>