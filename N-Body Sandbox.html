<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
/* ===================== THEME VARIABLES ===================== */
:root {
  /* Backgrounds */
  --bg-dark: #121212;          /* Page background */
  --bg-panel: #1e1e1e;         /* Side/stat panels */
  --bg-controls: #161616;      /* Top control panel */
  --bg-graph: #0f0f0f;         /* Graph background */

  /* Borders/Outlines */
  --border-default: #333333;   /* Standard borders */
  --border-strong: #444444;    /* Stronger panel separators */

  /* Text */
  --text-primary: #e0e0e0;     /* Main text */
  --text-secondary: #a1a1a1;   /* Labels, secondary info */
  --text-title: #ef4444;       /* Title (accented red) */

  /* Accents */
  --accent-hot: #ef4444;       /* Hot/red particles */
  --accent-cold: #3b82f6;      /* Cold/blue particles */
  --accent-green: #22c55e;     /* On/active state */
  --accent-yellow: #facc15;    /* Warnings/alerts */

  /* Controls */
  --slider-track: #222222;     /* Slider background */
  --slider-thumb: var(--accent-hot); /* Slider handle */
}

/* ===================== GLOBAL STYLES ===================== */
* {margin:0;padding:0;box-sizing:border-box}
body {
  background: var(--bg-dark);
  color: var(--text-primary);
  font-family: "Segoe UI","Roboto",sans-serif;
  overflow:hidden;
}

.container {width:100vw;height:100vh;display:flex;flex-direction:column}

/* ===================== TITLE ===================== */
.title-bar {
  position:absolute;
  top:6px;left:12px;
  font-size:14px;
  font-weight:bold;
  color: var(--text-title);
  opacity:0.85;
  pointer-events:none;
  z-index:1000;
  letter-spacing:1px;
}

/* ===================== CONTROLS (Compact Sleek) ===================== */
.controls {
  height:100px;
  background: var(--bg-controls);
  border-bottom:1px solid var(--border-strong);
  padding:4px 6px;
  display:flex;
  flex-wrap:wrap;
  gap:6px;
  align-items:center;
}

.control-group {
  display:flex;
  flex-direction:row;
  align-items:center;
  gap:4px;
  padding:2px 6px;
  border-radius:4px;
  background:rgba(255,255,255,0.03);
  border:1px solid var(--border-default);
}
.control-group label {
  font-size:12px;
  color: var(--text-secondary);
  cursor:help;
}
.control-group input[type=range] {
  width:70px;
  cursor:pointer;
  background: var(--slider-track);
  border-radius:10px;
  height:3px;
}
.control-group input[type=range]::-webkit-slider-thumb {
  background: var(--slider-thumb);
  border-radius:50%;
  border:none;
  width:10px;height:10px;
  appearance:none;
}
.control-group input[type=range]::-moz-range-thumb {
  background: var(--slider-thumb);
  border-radius:50%;
  border:none;
  width:10px;height:10px;
  cursor:pointer;
}
.control-group .value {
  font-size:9px;
  color: var(--accent-yellow);
}

/* ===================== BUTTONS ===================== */
.button {
  background: var(--bg-panel);
  border:1px solid var(--border-default);
  color: var(--text-primary);
  padding:4px 8px;
  border-radius:4px;
  cursor:pointer;
  font-size:10px;
  transition: background 0.2s, border 0.2s;
}
.button:hover {
  background: var(--accent-hot);
  border-color: var(--accent-hot);
  color:#fff;
}

/* ===================== SWITCHES ===================== */
.switch {display:flex;align-items:center;gap:4px}
.switch input {
  width: 28px;
  height: 14px;
  appearance: none;
  background: var(--slider-track);
  border-radius: 10px;
  position: relative;
  cursor: pointer;
  border: 1px solid var(--border-default);
}
.switch input:checked {background: var(--accent-hot);}
.switch input::before {
  content: '';
  position: absolute;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: var(--bg-dark);
  left: 2px;top:50%;transform: translateY(-50%);
  transition: transform .18s;
}
.switch input:checked::before {
  transform: translateY(-50%) translateX(12px);
}

/* ===================== MAIN CONTENT ===================== */
.main-content {flex:1;display:flex;height:calc(100vh - 70px)}
.simulation-area {flex:1;position:relative}
#canvas {width:100%;height:100%;background:#1a1a1a;display:block}

/* ===================== STATS/GRAPHS ===================== */
.stats-graphs {
  width:280px;
  background: var(--bg-panel);
  border-left:1px solid var(--border-strong);
  padding:4px;
  display:flex;
  flex-direction:column;
  gap:6px;
}
.stats {
  background: var(--bg-controls);
  border:1px solid var(--border-default);
  border-radius:4px;
  padding:6px;
  font-size:11px;
}
.stat-row {display:flex;justify-content:space-between;margin-bottom:3px}
.graph {
  background: var(--bg-graph);
  border:1px solid var(--border-default);
  border-radius:4px;
  height:100px;
  position:relative;
  padding:2px;
}
.graph-title {
  position:absolute;
  left:6px;top:4px;
  font-size:11px;
  color: var(--text-secondary);
}

/* ===================== TOOLTIP (Viewport-Clamped, Multiline) ===================== */
.ui-tooltip {
position: fixed; /* not clipped by parents; relative to viewport */
top: 0; left: 0; /* will be translated into place */
transform: translate(-9999px,-9999px);
background: var(--bg-panel);
color: var(--text-primary);
padding: 6px 8px;
border-radius: 6px;
border: 1px solid var(--accent-hot);
font-size: 10px;
line-height: 1.25;
max-width: 24ch; /* ~4–5 words per line; tweak 20–28ch */
white-space: normal; /* enable wrapping */
overflow-wrap: anywhere; /* prevent overflow */
box-shadow: 0 6px 18px rgba(0,0,0,.5);
z-index: 5000;
pointer-events: none; /* don't block mouse */
}


/* Optional: subtle entrance */
.ui-tooltip[data-visible="true"] { opacity: 1; transition: opacity .12s; }
.ui-tooltip:not([data-visible="true"]) { opacity: 0; }
</style>
</head>
<body>
<div class="container">
  <div class="controls">
    <div class="control-group">
      <label class="tooltip" data-tooltip="Controls total no of particles. Updates in real-time without reset. Use grid mode if too many particles are lagging the sim">Total Particles</label>
      <input id="particleCount" type="range" min="1" max="100000" step="1" value="10000" >
      <div class="value" id="particleCountValue">10000</div>
    </div>
    <div class="control-group">
      <label class="tooltip" data-tooltip="Controls the starting speed of the particles in the left box, updates real-time">Left Temp</label>
      <input id="leftTemp" type="range" min="0" max="10000" step="250" value="5000" >
      <div class="value" id="leftTempValue">5000</div>
    </div>
    <div class="control-group">
      <label class="tooltip" data-tooltip="Controls the starting speed of the particles in the right box, updates real-time">Right Temp</label>
      <input id="rightTemp" type="range" min="0" max="10000" step="250" value="50">
      <div class="value" id="rightTempValue">50</div>
    </div>
    <div class="control-group">
      <label class="tooltip" data-tooltip="Controls particle size, bigger particles collide more">Radius</label>
      <input id="radius" type="range" min="1" max="32" value="4"  >
      <div class="value" id="radiusValue">2px</div>
    </div>
    <div class="control-group">
      <label class="tooltip" data-tooltip="Particles hate each other">Pressure</label>
      <div class="switch">
        <input type="checkbox" id="pressureToggle">
        <div id="pressureLabel" style="color:#7A5836" >Off</div>
      </div>
    </div>
    <div class="control-group" style="display:none;>
      <label class="tooltip" data-tooltip="Strength of pressure force between particles">Pressure Force</label>
      <input id="pressureStrength" type="range" min="-30" max="30" value="5">
      <div class="value" id="pressureStrengthValue">5</div>
    </div>
    <div class="control-group">
      <label class="tooltip" data-tooltip="Make particles horny for each other!!!">Gravity</label>
      <div class="switch">
        <input type="checkbox" id="gravityToggle">
        <div id="gravityLabel" style="color:#7A5836">Off</div>
      </div>
    </div>
    <div class="control-group" style="display:none;>
      <label class="tooltip" data-tooltip="Strength of gravitational attraction between particles">Gravity Strength</label>
      <input type="range" id="gravityStrength" min="-100" max="100" step="1" value="10">
      <div class="value" id="gravityStrengthValue">10</div>
    </div>
    <div class="control-group" style="display:none;>
      <label class="tooltip" data-tooltip="Power law exponent for gravity force (2 = inverse square law)">Gravity Exponent</label>
      <input type="range" id="gravityExponent" min="0.1" max="3" step="0.1" value="2">
      <div class="value" id="gravityExponentValue">2.0</div>
    </div>
    <div class="control-group">
      <label class="tooltip" data-tooltip="Effective range of gravity, in grid cells. Higher values are more expensive.">Gravity Range</label>
      <input type="range" id="gravityDistance" min="1" max="20" step="1" value="3">
      <div class="value" id="gravityDistanceValue">3</div>
    </div>
    <div class="control-group">
      <label class="tooltip" data-tooltip="Particles loose energy when they collide">Friction</label>
      <div class="switch">
        <input type="checkbox" id="frictionToggle">
        <div id="frictionLabel" style="color:#7A5836" >Off</div>
      </div>
    </div>
    <div class="control-group">
      <label class="tooltip" data-tooltip="Particles loose speed slowly, fast particles loose more">Drag</label>
      <div class="switch">
        <input type="checkbox" id="dragToggle" >
        <div id="dragLabel" style="color:#7A5836" >Off</div>
      </div>
    </div>
    <div class="control-group" style="display:none;>
      <label class="tooltip" data-tooltip="Air resistance coefficient - higher values slow particles more">Drag Coefficient</label>
      <input id="dragCoeff" type="range" min="0.001" max="0.1" step="0.001" value="0.005">
      <div class="value" id="dragCoeffValue">0.05</div>
    </div>
    <div class="control-group">
      <label class="tooltip" data-tooltip="Progressively increases target FPS: 60→70→80→90... up to your display's maximum refresh rate">Uncap FPS</label>
      <div class="switch">
        <input type="checkbox" id="uncapFpsToggle" >
        <div id="uncapFpsLabel" style="color:#7A5836" >Off</div>
      </div>
    </div>
    <div class="control-group" style="display:none;>
      <label class="tooltip" data-tooltip="Particles move inward or outward from mouse when clicking and holding">Divergence</label>
      <div class="switch">
        <input type="checkbox" id="divergenceToggle" checked>
        <div id="divergenceLabel" style="color:#22c55e">Inward</div>
      </div>
    </div>
    <div class="control-group" style="display:none;>
      <label class="tooltip" data-tooltip="Particles rotate clockwise or anticlockwise around mouse when clicking and holding">Curl</label>
      <div class="switch">
        <input type="checkbox" id="curlToggle" checked>
        <div id="curlLabel" style="color:#22c55e">Clockwise</div>
      </div>
    </div>
    <div class="control-group">
      <label class="tooltip" data-tooltip="SAP for accuracy, Grid for speed and 3d effect with large radii particles">Collision Mode</label>
      <div class="switch">
        <input type="checkbox" id="collisionMode" checked="">
        <div id="collisionModeLabel" style="color:#7A5836" class="tooltip" data-tooltip="SAP for accuracy, Grid for speed and 3d effect with large radii particles">SAP</div>
      </div>
	</div>
    <div class="control-group">
      <label class="tooltip" data-tooltip="Size of the spatial grid cells for force calculations. Smaller is more precise but can be slower.">Grid Size</label>
      <input type="range" id="gridSize" min="5" max="50" step="5" value="20">
      <div class="value" id="gridSizeValue">20px</div>
    </div>
    
    <button class="button" id="resetBtn">Reset</button>
    <button class="button" id="pauseBtn">Pause</button>
    <button class="button" id="pipeBtn">Open Pipe</button>
	
    <div class="control-group">
      <label class="tooltip" data-tooltip="Controls size of opening in the middle, higher value opens more">Pipe Height</label>
      <input id="pipeHeight" type="range" min="0" max="100" value="1"  >
      <div class="value" id="pipeHeightValue">1%</div>
    </div>
    <div class="control-group" style="display:none;>
      <label class="tooltip" data-tooltip="Moves the central dividing wall. 50% is center, 0% is far left, 100% is far right.">Wall Position</label>
      <input id="wallPosition" type="range" min="0" max="100" value="50">
      <div class="value" id="wallPositionValue">50%</div>
    </div>
	
    <div class="control-group" style="display:none;>
      <label class="tooltip" data-tooltip="Demon likes to be right so only lets hot particles in the right box">Maxwell's Demon</label>
      <div class="switch">
        <input type="checkbox" id="maxwellToggle">
        <div id="maxwellLabel" style="color:#7A5836" >Off</div>
      </div>
    </div>
    <div class="control-group" style="display:none;>
      <label class="tooltip" data-tooltip="250=demon wants the hottest particles only, 1= demon likes partcles which are moving.">Demon Threshold</label>
      <input id="demonThreshold" type="range" min="1" max="250" value="10">
      <div class="value" id="demonThresholdValue">10</div>
    </div>
    <div class="control-group">
      <label class="tooltip" data-tooltip="helps in collision detection when particles pass through closed wall, lower to boost sim speed">Substeps</label>
      <input id="substeps" type="range" min="1" max="8" value="2" >
      <div class="value" id="substepsValue">2</div>
    </div>
    
    <div class="control-group">
      <label class="tooltip" data-tooltip="Treat particles as nodes with connecting bonds">Nodes</label>
      <div class="switch">
        <input type="checkbox" id="nodeToggle">
        <div id="nodeLabel" style="color:#7A5836">Off</div>
      </div>
    </div>
    <div class="control-group">
      <label class="tooltip" data-tooltip="Maximum number of bonds per particle. 'All' means unlimited connections.">Node Branches</label>
      <input id="nodeBranches" type="range" min="0" max="11" step="1" value="3">
      <div class="value" id="nodeBranchesValue">3</div>
    </div>
    <div class="control-group">
      <label class="tooltip" data-tooltip="Maximum distance for bond formation in pixels">Node Max Dist</label>
      <input id="nodeMaxDist" type="range" min="10" max="2000" step="10" value="200">
      <div class="value" id="nodeMaxDistValue">200px</div>
    </div>
    <div class="control-group">
      <label class="tooltip" data-tooltip="Minimum distance for bond formation in pixels">Node Min Dist</label>
      <input id="nodeMinDist" type="range" min="0" max="200" step="1" value="100">
      <div class="value" id="nodeMinDistValue">100px</div>
    </div>
    <div class="control-group">
      <label class="tooltip" data-tooltip="Spring stiffness for bonds. Higher values make more rigid connections.">Bond Stiffness</label>
      <input id="bondStiffness" type="range" min="-2" max="1" step="0.1" value="0">
      <div class="value" id="bondStiffnessValue">1.00</div>
    </div>
    <div class="control-group">
      <label class="tooltip" data-tooltip="Enable dynamic bond forces using spring physics">Bond Dynamics</label>
      <div class="switch">
        <input type="checkbox" id="bondDynamicsToggle">
        <div id="bondDynamicsLabel" style="color:#7A5836">Off</div>
      </div>
    </div>
    
	<div><span>Physics FPS:</span><span id="physicsFps">0</span></div>
  </div>
  
  <div class="main-content">
    <div class="simulation-area">
      <canvas id="canvas" width="1510" height="832" style="width: 1208px; height: 665.6px;"></canvas>
	  <canvas id="overlay" style="position:absolute; inset:0; pointer-events:none;"></canvas>
      <div class="loading" id="loading" style="display: none;">Seeding particles...</div>
    </div>
    <div class="stats-graphs">
      <div class="stats" id="stats">
        <div class="stat-row"><span>FPS:</span><span id="fps">60</span></div>
        <div class="stat-row"><span>Target FPS:</span><span id="targetFps">60</span></div>
        <div class="stat-row"><span>Bond Checks:</span><span id="bondChecks">0</span></div>
        <div class="stat-row"><span>Total Particles:</span><span id="totalParticles">10000</span></div>
        <div class="stat-row"><span>Collisions/sec:</span><span id="collisionRate">124</span></div>
        <div class="stat-row"><span>Collision Checks:</span><span id="collisionChecks">9074</span></div>
        <div class="stat-row"><span>Left Box Temp:</span><span id="leftBoxTemp">0.00</span></div>
        <div class="stat-row"><span>Right Box Temp:</span><span id="rightBoxTemp">0.00</span></div>
        <div class="stat-row"><span>Left Avg Speed:</span><span id="leftAvgSpeed">0.00</span></div>
        <div class="stat-row"><span>Right Avg Speed:</span><span id="rightAvgSpeed">0.00</span></div>
        <div class="stat-row"><span>Left Max Speed:</span><span id="leftMaxSpeed">0.00</span></div>
        <div class="stat-row"><span>Right Max Speed:</span><span id="rightMaxSpeed">0.00</span></div>
        <div class="stat-row"><span>Total Bonds:</span><span id="totalBonds">0</span></div>
        <div class="stat-row"><span>Avg Bonds/Particle:</span><span id="avgBondsPerParticle">0.00</span></div>
      </div>
      <div class="graph"><div class="graph-title">Left Temp (Recent)</div><canvas id="leftTempRecentGraph" width="280" height="90"></canvas></div>
      <div class="graph"><div class="graph-title">Right Temp (Recent)</div><canvas id="rightTempRecentGraph" width="280" height="90"></canvas></div>
      <div class="graph"><div class="graph-title">Left Temp (Full)</div><canvas id="leftTempFullGraph" width="280" height="90"></canvas></div>
      <div class="graph"><div class="graph-title">Right Temp (Full)</div><canvas id="rightTempFullGraph" width="280" height="90"></canvas></div>
    </div>
  </div>
</div>

<script>

// js to make css tooltip not going offscreen stuff
(function(){
// Single, reusable tooltip element
const tip = document.createElement('div');
tip.className = 'ui-tooltip';
document.body.appendChild(tip);


let currentTarget = null;
const GAP = 8; // px gap from target


function placeTooltip(target){
const rect = target.getBoundingClientRect();


// Preferred position: below center of target
let x = rect.left + rect.width/2;
let y = rect.bottom + GAP;


// Set content first so we can measure size
// (content already set in showTooltip)
tip.style.transform = 'translate(0px,0px)';
const w = tip.offsetWidth;
const h = tip.offsetHeight;


// Clamp horizontally to viewport
let left = x - w/2;
left = Math.max(8, Math.min(left, window.innerWidth - w - 8));


// If doesn't fit below, place above
let top = y;
if (top + h + 8 > window.innerHeight) {
top = rect.top - h - GAP;
}


tip.style.transform = `translate(${left}px, ${Math.max(8, top)}px)`;
}


function showTooltip(target){
const txt = target.getAttribute('data-tooltip');
if (!txt) return;
currentTarget = target;
tip.textContent = txt;
tip.setAttribute('data-visible','true');
placeTooltip(target);
}


function hideTooltip(){
currentTarget = null;
tip.removeAttribute('data-visible');
// park it offscreen
tip.style.transform = 'translate(-9999px,-9999px)';
}


// Event bindings for any element with data-tooltip
  function bind(el){
    el.addEventListener('mouseenter', ()=> showTooltip(el));
    el.addEventListener('mouseleave', hideTooltip);
    el.addEventListener('mousemove', ()=> placeTooltip(el));
    el.addEventListener('focus', ()=> showTooltip(el));
    el.addEventListener('blur', hideTooltip);
    el.addEventListener('touchstart', ()=> showTooltip(el), {passive:true});
    el.addEventListener('touchend', hideTooltip, {passive:true});
  }

  // 👇 Expose one global function
  window.bindTooltips = function(){
    document.querySelectorAll('[data-tooltip]').forEach(bind);
  };
})();

// ---------- Config & state ----------
const config = {
  particleCount: 10000,
  leftTemp: 5000,
  rightTemp: 50,
  radius: 4,
  pipeHeight: 1,
  substeps: 2,
  tunneling: 5000,
  useSAP: true,
  pipeOpen: false,
  width: 1000,
  height: 1000,
  gravity: false,
  friction: false,
  drag: false,
  pressure: false,
  maxwellDemon: false,
  demonSpeedThreshold: 10,
  uncapFps: false,
  gravityStrength: 10,
  gravityExponent: 2.0,
  frictionCoeff: 0.999,
  dragCoeff: 0.005,
  pressureStrength: 5,
  gridSize: 20,
  gravityDistance: 3,
  wallPosition: 50, // Percentage (0-100)
  divergenceInward: true, // true = inward, false = outward
  curlClockwise: true, // true = clockwise, false = anticlockwise
  // Node/Bond configuration
  nodeMode: false,
  nodeBranches: 3, // -1 = "all", otherwise 0-10
  nodeMaxDist: 200, // pixels
  nodeMinDist: 100, // pixels
  bondStiffness: 1.0, // spring constant
  bondDynamics: false, // enable/disable bond forces
  bondDamping: 0.1, // damping coefficient for bonds
};

let canvas = document.getElementById('canvas');
let overlay = document.getElementById('overlay');
let renderer = null; // Class-based renderer (WebGL + 2D fallback)
let graphManager = null; // Class-based graphs/history manager
let gl = null;
let program = null;
let positionBuffer, colorBuffer, radiusBuffer;
let isRunning = true;
let lastRAF = performance.now();
let fpsSmooth = 60;

// Graph/History
const maxFullHistory = 2000;
const recentPoints = 120;
let leftFull = [];
let rightFull = [];
let leftRecent = [];
let rightRecent = [];

// Stats
const stats = { fps:0, collisionRate:0, collisionChecks:0, leftBoxTemp:0, rightBoxTemp:0, totalParticles:0, leftAvgSpeed:0, rightAvgSpeed:0, leftMaxSpeed:0, rightMaxSpeed:0, totalBonds:0, avgBondsPerParticle:0 };
stats.bondChecks = 0;
// Bond System
const BondSystem = {
  bonds: [], // Array of {i, j, length} objects
  particleBonds: [], // Array of Set objects, one per particle
  enabled: false,
  updateCounter: 0,
  updateFrequency: 10, // Update bonds every 10 physics ticks
  bondChecksThisFrame: 0,
  
  init(particleCount) {
    this.bonds = [];
    this.particleBonds = [];
    for (let i = 0; i < particleCount; i++) {
      this.particleBonds.push(new Set());
    }
  },
  
  clear() {
    this.bonds = [];
    for (let bonds of this.particleBonds) {
      bonds.clear();
    }
  },
  
  addBond(i, j, distance) {
    if (i === j) return false;
    if (this.particleBonds[i].has(j)) return false; // Already bonded
    
    const maxBranches = config.nodeBranches === -1 ? Infinity : config.nodeBranches;
    if (this.particleBonds[i].size >= maxBranches || this.particleBonds[j].size >= maxBranches) {
      return false; // Capacity exceeded
    }
    
    this.bonds.push({i, j, length: distance});
    this.particleBonds[i].add(j);
    this.particleBonds[j].add(i);
    return true;
  },
  
  removeBond(bondIndex) {
    if (bondIndex < 0 || bondIndex >= this.bonds.length) return;
    
    const bond = this.bonds[bondIndex];
    this.particleBonds[bond.i].delete(bond.j);
    this.particleBonds[bond.j].delete(bond.i);
    this.bonds.splice(bondIndex, 1);
  },

  update(particles, particleCount, cfg) {
    if (!this.enabled) {
      this.bondChecksThisFrame = 0;
      return;
    }
    
    this.updateCounter++;
    if (this.updateCounter >= this.updateFrequency) {
      this.updateCounter = 0;
      this.performBondUpdate(particles, particleCount, cfg);
    } else {
      this.validateExistingBonds(particles, particleCount, cfg);
    }
  },

  getBondChecks() {
    return this.bondChecksThisFrame;
  },

  validateExistingBonds(particles, particleCount, cfg) {
    this.bondChecksThisFrame = 0;
    if (cfg.nodeMinDist > cfg.nodeMaxDist) return;

    const minDist = cfg.nodeMinDist;
    const maxDist = cfg.nodeMaxDist === 1000 ? 10000 : cfg.nodeMaxDist;

    for (let i = this.bonds.length - 1; i >= 0; i--) {
      const bond = this.bonds[i];
      const iIdx = bond.i * 8;
      const jIdx = bond.j * 8;

      const dx = particles[jIdx] - particles[iIdx];
      const dy = particles[jIdx + 1] - particles[iIdx + 1];
      const dist = Math.sqrt(dx * dx + dy * dy);
      this.bondChecksThisFrame++;
      if (dist < minDist || dist > maxDist) {
        this.removeBond(i);
      }
    }
  },
  
  performBondUpdate(particles, particleCount, cfg) {
    this.bondChecksThisFrame = 0; // Reset for this frame
    
    // Early return if bonds are disabled by invalid settings
    if (cfg.nodeBranches === 0) return; // No bonds allowed
    if (cfg.nodeMinDist > cfg.nodeMaxDist) return; // Invalid distance range
    
    const minDist = cfg.nodeMinDist;
    const maxDist = cfg.nodeMaxDist === 1000 ? 10000 : cfg.nodeMaxDist; // Use 10000 instead of Infinity
    const maxBranches = cfg.nodeBranches === -1 ? Infinity : cfg.nodeBranches;
    // First, prune excess bonds when branch limit is reduced
    if (maxBranches !== Infinity) {
      for (let i = 0; i < particleCount; i++) {
        while (this.particleBonds[i].size > maxBranches) {
          // Find and remove the oldest bond for this particle
          for (let j = this.bonds.length - 1; j >= 0; j--) {
            const bond = this.bonds[j];
            if (bond.i === i || bond.j === i) {
              this.removeBond(j);
              break;
            }
          }
        }
      }
    }
    
    this.validateExistingBonds(particles, particleCount, cfg); // Also validate on full update
    
    // Form new bonds (only check a subset for performance)
    const checkFraction = particleCount > 1000 ? 0.1 : 0.5;
    const checkCount = Math.floor(particleCount * checkFraction);
    
    for (let i = 0; i < checkCount; i++) {
      const particleI = Math.floor(Math.random() * particleCount);
      const iIdx = particleI * 8;
      const maxBranches = cfg.nodeBranches === -1 ? Infinity : cfg.nodeBranches;
      
      if (this.particleBonds[particleI].size >= maxBranches) continue;
      
      // Check nearby particles using spatial grid
      const cellSize = cfg.gridSize;
      const x = particles[iIdx];
      const y = particles[iIdx + 1];
      const gx = Math.floor(x / cellSize);
      const gy = Math.floor(y / cellSize);
      
      const searchRange = Math.ceil(maxDist / cellSize);
      
      for (let dx = -searchRange; dx <= searchRange; dx++) {
        for (let dy = -searchRange; dy <= searchRange; dy++) {
          const cellX = gx + dx;
          const cellY = gy + dy;
          // Use the existing spatial grid from PhysicsModule if available
          // For now, we'll do a simple distance check
          
          for (let particleJ = 0; particleJ < particleCount; particleJ++) {
            if (particleI === particleJ) continue;
            if (this.particleBonds[particleI].has(particleJ)) continue;
            if (this.particleBonds[particleJ].size >= maxBranches) continue;
            
            const jIdx = particleJ * 8;
            const dx = particles[jIdx] - x;
            const dy = particles[jIdx + 1] - y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            this.bondChecksThisFrame++; // Count this check
            if (dist >= minDist && dist <= maxDist) {
              if (this.addBond(particleI, particleJ, dist)) {
                break; // Only add one bond per iteration for this particle
              }
            }
          }
        }
      }
    }
  },
  
  applyBondForces(particles, particleCount, cfg, dt) {
    if (!this.enabled || !cfg.bondDynamics) return;
    
    const k = cfg.bondStiffness;
    const damping = cfg.bondDamping;
    const equilibriumLength = (cfg.nodeMaxDist + cfg.nodeMinDist) / 2;
    
    for (const bond of this.bonds) {
      const iIdx = bond.i * 8;
      const jIdx = bond.j * 8;
      
      const dx = particles[jIdx] - particles[iIdx];
      const dy = particles[jIdx + 1] - particles[iIdx + 1];
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist === 0) continue;
      
      // Hooke's law force
      const force = -k * (dist - equilibriumLength);
      
      // Normalize direction
      const nx = dx / dist;
      const ny = dy / dist;
      
      // Add damping
      const dvx = particles[jIdx + 2] - particles[iIdx + 2];
      const dvy = particles[jIdx + 3] - particles[iIdx + 3];
      const relativeVelocity = dvx * nx + dvy * ny;
      const dampingForce = -damping * relativeVelocity;
      
      const totalForce = force + dampingForce;
      const fx = totalForce * nx;
      const fy = totalForce * ny;
      
      // Apply forces (assuming unit mass)
      particles[iIdx + 2] -= fx * dt;
      particles[iIdx + 3] -= fy * dt;
      particles[jIdx + 2] += fx * dt;
      particles[jIdx + 3] += fy * dt;
    }
  },
  
  render(ctx, particles, particleCount) {
    if (!this.enabled || this.bonds.length === 0) return;
    
    ctx.save();
    ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
    ctx.lineWidth = 1;
    ctx.globalCompositeOperation = 'screen';
    
    ctx.beginPath();
    for (const bond of this.bonds) {
      const iIdx = bond.i * 8;
      const jIdx = bond.j * 8;
      
      ctx.moveTo(particles[iIdx], particles[iIdx + 1]);
      ctx.lineTo(particles[jIdx], particles[jIdx + 1]);
    }
    ctx.stroke();
    ctx.restore();
  }
};

// Mouse interaction state
let mouseState = {
  isDown: false,
  x: 0,
  y: 0,
  forceStrength: 100 // Strength of the mouse force effect
};

// FPS targeting variables
let targetFps = 60;

// ---------- Graph reset function ----------
function resetGraphs() {
  if (graphManager) graphManager.reset();
}

// ---------- Utilities ----------
function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
function hslToRgb(h,s,l){ // h in [0,1]
  let r,g,b;
  if(s==0) r=g=b=l; else{
    const q = l<0.5?l*(1+s):l+s-l*s; const p = 2*l-q;
    const hue2rgb=(p,q,t)=>{ if(t<0) t+=1; if(t>1) t-=1; if(t<1/6) return p+(q-p)*6*t; if(t<1/2) return q; if(t<2/3) return p+(q-p)*(2/3-t)*6; return p };
    r=hue2rgb(p,q,h+1/3); g=hue2rgb(p,q,h); b=hue2rgb(p,q,h-1/3);
  }
  return [r,g,b];
}

// ---------- Class-based Architecture: Renderer, GraphManager, and Stubs ----------
class Renderer {
  constructor(canvas, overlayCanvas, cfg) {
    this.canvas = canvas;
    this.overlay = overlayCanvas;
    this.config = cfg;
    this.gl = null;
    this.program = null;
    this.buffers = { pos: null, col: null, rad: null };
    this.locations = { pos: null, col: null, rad: null, res: null, pr: null };
    this.tmpPos = new Float32Array(0);
    this.tmpCols = new Float32Array(0);
    this.tmpRads = new Float32Array(0);
    this.mode = 'Canvas2D';
    this.isWebGL2 = false;
    this.init();
  }
  _compileOrFallback(gl, vsSource, fsSource) {
    const vs = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vs, vsSource); gl.compileShader(vs);
    if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) { return null; }
    const fs = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fs, fsSource); gl.compileShader(fs);
    if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) { return null; }
    const prog = gl.createProgram(); gl.attachShader(prog, vs); gl.attachShader(prog, fs); gl.linkProgram(prog);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) { return null; }
    return prog;
  }
  init() {
    // Prefer high-performance GPU and disable antialias for speed
    this.gl = this.canvas.getContext('webgl2', { antialias: false, powerPreference: 'high-performance' })
           || this.canvas.getContext('webgl');
    const gl = this.gl;
    if (!gl) { console.warn('WebGL unavailable – falling back to 2D render.'); this.mode = 'Canvas2D'; return; }

    this.isWebGL2 = (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext);

    // WebGL2 shaders
    const v300 = `#version 300 es
      in vec2 a_position; in vec3 a_color; in float a_radius;
      uniform vec2 u_resolution; uniform float u_pixelRatio;
      out vec3 v_color;
      void main(){
        vec2 pos = ((a_position / u_resolution) * 2.0 - 1.0) * vec2(1.0, -1.0);
        gl_Position = vec4(pos, 0, 1);
        gl_PointSize = a_radius * 1.0 * u_pixelRatio;
        v_color = a_color;
      }`;
    const f300 = `#version 300 es
      precision mediump float; in vec3 v_color; out vec4 outColor;
      void main(){ vec2 c = gl_PointCoord - vec2(0.5); float d = length(c);
        if(d>0.5) discard; float alpha = 1.0 - smoothstep(0.3,0.5,d);
        outColor = vec4(v_color, alpha);
      }`;

    // WebGL1 shaders
    const v100 = `attribute vec2 a_position; attribute vec3 a_color; attribute float a_radius;
      uniform vec2 u_resolution; uniform float u_pixelRatio; varying vec3 v_color;
      void main(){ vec2 pos = ((a_position / u_resolution) * 2.0 - 1.0) * vec2(1.0, -1.0);
        gl_Position = vec4(pos, 0.0, 1.0); gl_PointSize = a_radius * 1.0 * u_pixelRatio; v_color = a_color; }`;
    const f100 = `precision mediump float; varying vec3 v_color;
      void main(){ vec2 c = gl_PointCoord - vec2(0.5); float d = length(c);
        if (d > 0.5) discard; float alpha = 1.0 - smoothstep(0.3,0.5,d); gl_FragColor = vec4(v_color, alpha); }`;

    // Try WebGL2 first, then fallback to WebGL1
    if (this.isWebGL2) {
      this.program = this._compileOrFallback(gl, v300, f300);
      if (this.program) { this.mode = 'WebGL2'; }
    }
    if (!this.program) {
      if (!this.isWebGL2) { this.mode = 'WebGL1'; }
      this.program = this._compileOrFallback(gl, v100, f100);
      if (!this.program) {
        console.warn('Shader compile/link failed – falling back to Canvas2D.');
        this.gl = null; this.mode = 'Canvas2D'; return;
      }
    }

    this.buffers.pos = gl.createBuffer();
    this.buffers.col = gl.createBuffer();
    this.buffers.rad = gl.createBuffer();

    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.clearColor(0.05, 0.05, 0.05, 1);

    this.locations.pos = gl.getAttribLocation(this.program,'a_position');
    this.locations.col = gl.getAttribLocation(this.program,'a_color');
    this.locations.rad = gl.getAttribLocation(this.program,'a_radius');
    this.locations.res = gl.getUniformLocation(this.program,'u_resolution');
    this.locations.pr  = gl.getUniformLocation(this.program,'u_pixelRatio');
  }
  getRenderMode() { return this.gl ? this.mode : 'Canvas2D'; }
  _ensureTmp(count) {
    if (this.tmpPos.length !== count * 2) { this.tmpPos = new Float32Array(count * 2); }
    if (this.tmpCols.length !== count * 3) { this.tmpCols = new Float32Array(count * 3); }
    if (this.tmpRads.length !== count) { this.tmpRads = new Float32Array(count); }
  }
  resize() {
    const rect = this.canvas.parentElement.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const width = Math.floor(rect.width * dpr);
    const height = Math.floor(rect.height * dpr);

    this.canvas.width = width; this.canvas.height = height;
    this.canvas.style.width = rect.width + 'px'; this.canvas.style.height = rect.height + 'px';

    this.overlay.width = width; this.overlay.height = height;
    this.overlay.style.width = this.canvas.style.width; this.overlay.style.height = this.canvas.style.height;

    this.config.width = width; this.config.height = height;
    if (this.gl) this.gl.viewport(0, 0, width, height);

    this.drawWalls();
  }
  render(particles, count) {
    if (!particles || count <= 0) return;

    if (!this.gl) {
      // 2D fallback rendering
      const ctx = this.canvas.getContext('2d');
      ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
      ctx.globalCompositeOperation = 'lighter';
      for (let i = 0; i < count; i++) {
        const idx=i*8;
        const rgb=[particles[idx+4]*255,particles[idx+5]*255,particles[idx+6]*255];
        ctx.fillStyle = `rgb(${rgb[0]|0},${rgb[1]|0},${rgb[2]|0})`;
        ctx.beginPath(); ctx.arc(particles[idx],particles[idx+1],particles[idx+7],0,Math.PI*2); ctx.fill();
      }
      ctx.globalCompositeOperation = 'source-over';
      return;
    }

    const gl = this.gl;
    this._ensureTmp(count);
    const pos = this.tmpPos, cols = this.tmpCols, rads = this.tmpRads;
    for (let i = 0; i < count; i++) {
      const idx = i*8, i2=i*2, i3=i*3;
      pos[i2] = particles[idx]; pos[i2+1] = particles[idx+1];
      cols[i3] = particles[idx+4]; cols[i3+1] = particles[idx+5]; cols[i3+2] = particles[idx+6];
      rads[i] = particles[idx+7];
    }

    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(this.program);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.pos); gl.bufferData(gl.ARRAY_BUFFER, pos, gl.STREAM_DRAW);
    gl.enableVertexAttribArray(this.locations.pos); gl.vertexAttribPointer(this.locations.pos,2,gl.FLOAT,false,0,0);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.col); gl.bufferData(gl.ARRAY_BUFFER, cols, gl.STREAM_DRAW);
    gl.enableVertexAttribArray(this.locations.col); gl.vertexAttribPointer(this.locations.col,3,gl.FLOAT,false,0,0);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.rad); gl.bufferData(gl.ARRAY_BUFFER, rads, gl.STREAM_DRAW);
    gl.enableVertexAttribArray(this.locations.rad); gl.vertexAttribPointer(this.locations.rad,1,gl.FLOAT,false,0,0);
    gl.uniform2f(this.locations.res, this.config.width, this.config.height);
    gl.uniform1f(this.locations.pr, window.devicePixelRatio || 1);
    gl.drawArrays(gl.POINTS, 0, count);
  }
  drawWalls() {
    const ctx = this.overlay.getContext('2d');
    const W = this.overlay.width, H = this.overlay.height;
    const cx = W * (this.config.wallPosition / 100);
    const pipePct = this.config.pipeHeight * 0.01;
    const pipeOpen = this.config.pipeOpen;
    const openH = Math.max(2, Math.floor(H * pipePct));
    const wallThickness = Math.max(2, Math.floor(Math.min(W, H) * 0.003));

    ctx.clearRect(0, 0, W, H);
    ctx.strokeStyle = '#999';
    ctx.fillStyle   = '#ff4040';
    ctx.lineWidth   = wallThickness;
    ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, H); ctx.stroke();

    if (pipeOpen && openH > 0) {
      const y0 = Math.floor((H - openH) / 2);
      const y1 = y0 + openH;
      ctx.strokeStyle = '#0f0f0f'; ctx.lineWidth = wallThickness * 1.8;
      ctx.beginPath(); ctx.moveTo(cx, y0); ctx.lineTo(cx, y1); ctx.stroke();
      ctx.fillStyle = '#ffeb3b';
      ctx.fillRect(cx - wallThickness, y0 - wallThickness, wallThickness * 2, wallThickness);
      ctx.fillRect(cx - wallThickness, y1, wallThickness * 2, wallThickness);
    }
  }
}

class GraphManager {
  constructor() {
    this.leftFull = []; this.rightFull = [];
    this.leftRecent = []; this.rightRecent = [];
  }
  reset() {
    this.leftFull = []; this.rightFull = [];
    this.leftRecent = []; this.rightRecent = [];
    const ids = ['leftTempRecentGraph','rightTempRecentGraph','leftTempFullGraph','rightTempFullGraph'];
    ids.forEach(id => { const c = document.getElementById(id); if (c) c.getContext('2d').clearRect(0,0,c.width,c.height); });
  }
  pushHistory(l, r) {
    this.leftRecent.push(l); this.rightRecent.push(r);
    this.leftFull.push(l); this.rightFull.push(r);
    if (this.leftRecent.length > recentPoints) this.leftRecent.shift();
    if (this.rightRecent.length > recentPoints) this.rightRecent.shift();
    if (this.leftFull.length > maxFullHistory) this.leftFull.shift();
    if (this.rightFull.length > maxFullHistory) this.rightFull.shift();
  }
  drawAll() {
    drawMiniGraph(document.getElementById('leftTempRecentGraph'), this.leftRecent, true);
    drawMiniGraph(document.getElementById('rightTempRecentGraph'), this.rightRecent, true);
    drawMiniGraph(document.getElementById('leftTempFullGraph'), this.leftFull, false);
    drawMiniGraph(document.getElementById('rightTempFullGraph'), this.rightFull, false);
  }
}

// Future-friendly stubs to enable easy QoL and presets later
class PresetManager { getPresets(){ return []; } loadPreset(name){ /* hook up later */ } }
class SaveLoadManager { saveConfig(cfg){ /* hook up later */ } loadConfig(obj){ /* hook up later */ } }

// ---------- WebGL setup ----------
function initWebGL(){
  gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
  if(!gl){ document.getElementById('loading').textContent = 'WebGL unavailable – falling back to 2D render.'; return false; }

  // shaders
  const vsrc = `#version 300 es
    in vec2 a_position; in vec3 a_color; in float a_radius;
    uniform vec2 u_resolution; uniform float u_pixelRatio;
    out vec3 v_color; out float v_radius;
    void main(){ vec2 pos = ((a_position / u_resolution) * 2.0 - 1.0) * vec2(1.0, -1.0);
      gl_Position = vec4(pos,0,1); 
	  gl_PointSize = a_radius * 1.0 * u_pixelRatio; 
	  v_color = a_color; 
	  v_radius = a_radius * u_pixelRatio; }
  `;
  const fsrc = `#version 300 es
    precision mediump float; in vec3 v_color; in float v_radius; out vec4 outColor;
    void main(){ vec2 c = gl_PointCoord - vec2(0.5); float d = length(c);
      if(d>0.5) discard; 
	  float alpha = 1.0 - smoothstep(0.3,0.5,d);
      outColor = vec4(v_color, alpha);
    }
  `;
  const vs = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vs,vsrc); gl.compileShader(vs);
  const fs = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fs,fsrc); gl.compileShader(fs);
  program = gl.createProgram(); gl.attachShader(program,vs); gl.attachShader(program,fs); gl.linkProgram(program);
  positionBuffer = gl.createBuffer(); colorBuffer = gl.createBuffer(); radiusBuffer = gl.createBuffer();
  gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); gl.clearColor(0,0,0,1);
  return true;
}

function resize(){ if (renderer) renderer.resize(); }
window.addEventListener('resize', () => { if (renderer) renderer.resize(); });
// Instantiate managers (class-based) and size once
renderer = new Renderer(canvas, document.getElementById('overlay'), config);
graphManager = new GraphManager();
resize();

// ---------- Optimized Physics Module ----------
let PhysicsModule = (function(){
  const Module = { ready:false, particles:null, particleCount:0, bondChecks: 0 };
  
  // Spatial grid for force calculations
  let spatialGrid = null;
  let gridWidth = 0;
  let gridHeight = 0;

  // Force sampling variables - persistent across calls for better distribution
  let forceUpdateOffset = 0;

  function reinitGrid(width, height, cellSize) {
    gridWidth = Math.ceil(width / cellSize);
    gridHeight = Math.ceil(height / cellSize);
    spatialGrid = new Array(gridWidth * gridHeight);
    for(let i = 0; i < spatialGrid.length; i++) {
      spatialGrid[i] = [];
    }
  }

  // Teleportation functions for Maxwell's Demon
  function teleportSlowParticle(p, n, cx, thresholdSq, direction) {
    const candidates = [];
    for(let i = 0; i < n; i++) {
      const idx = i * 8;
      const px = p[idx];
      const speedSq = p[idx+2]*p[idx+2] + p[idx+3]*p[idx+3];
      if(direction === 'rightToLeft' && px > cx && speedSq < thresholdSq) {
        candidates.push(idx);
      }
    }
    if(candidates.length > 0) {
      const chosenIdx = candidates[Math.floor(Math.random() * candidates.length)];
      p[chosenIdx] = Math.random() * (cx - 20) + 10;
      p[chosenIdx + 1] = Math.random() * (config.height - 20) + 10;
    }
  }
  
  function teleportFastParticle(p, n, cx, thresholdSq, direction) {
    const candidates = [];
    for(let i = 0; i < n; i++) {
      const idx = i * 8;
      const px = p[idx];
      const speedSq = p[idx+2]*p[idx+2] + p[idx+3]*p[idx+3];
      if(direction === 'leftToRight' && px < cx && speedSq >= thresholdSq) {
        candidates.push(idx);
      }
    }
    if(candidates.length > 0) {
      const chosenIdx = candidates[Math.floor(Math.random() * candidates.length)];
      p[chosenIdx] = Math.random() * (config.width - cx - 20) + cx + 10;
      p[chosenIdx + 1] = Math.random() * (config.height - 20) + 10;
    }
  }

  function clearSpatialGrid() {
    for(let i = 0; i < spatialGrid.length; i++) {
      spatialGrid[i].length = 0;
    }
  }

  function addToSpatialGrid(particleIndex, x, y, cellSize) {
    const gx = Math.floor(x / cellSize);
    const gy = Math.floor(y / cellSize);
    if(gx >= 0 && gx < gridWidth && gy >= 0 && gy < gridHeight) {
      spatialGrid[gy * gridWidth + gx].push(particleIndex);
    }
  }

  function updateParticleCount(newCount) {
    if (newCount === Module.particleCount) return;
	BondSystem.clear();
    const oldCount = Module.particleCount;
    const newParticles = new Float32Array(newCount * 8);
    const copyCount = Math.min(newCount, oldCount);
    
    if (oldCount > 0 && Module.particles) {
      for (let i = 0; i < copyCount * 8; i++) {
        newParticles[i] = Module.particles[i];
      }
    }
    
    if (newCount > oldCount) {
      const w = config.width, h = config.height, margin = config.radius + 1;
      const cx = w * (config.wallPosition / 100);
      for (let i = oldCount; i < newCount; i++) {
        const idx = i * 8;
        const isLeft = (i % 2 === 0);
        const bxMin = isLeft ? margin : cx + margin;
        const bxMax = isLeft ? cx - margin : w - margin;
        newParticles[idx] = Math.random() * (bxMax - bxMin) + bxMin;
        newParticles[idx + 1] = Math.random() * (h - 2 * margin) + margin;
        const speed = (isLeft ? config.leftTemp : config.rightTemp) * (Math.random() * 0.6 + 0.7) / 50;
        const ang = Math.random() * Math.PI * 2;
        newParticles[idx + 2] = Math.cos(ang) * speed;
        newParticles[idx + 3] = Math.sin(ang) * speed;
        newParticles[idx + 7] = config.radius;
      }
    }
    
    Module.particles = newParticles;
    Module.particleCount = newCount;
	BondSystem.init(newCount);
    updateColors();
  }

  function init(count){
    Module.particleCount = count; 
    Module.particles = new Float32Array(count * 8);
    const w = config.width, h = config.height, margin = config.radius + 1;
    const cx = w * (config.wallPosition / 100);
    
    reinitGrid(w, h, config.gridSize);
    
    // Initialize bond system
    BondSystem.init(count);
    
    for(let i=0;i<count;i++){ 
      const idx=i*8; 
      const left = (i%2===0);
      const bxMin = left? margin : cx+margin; 
      const bxMax = left? cx-margin : w-margin;
      Module.particles[idx] = Math.random()*(bxMax-bxMin)+bxMin; 
      Module.particles[idx+1] = Math.random()*(h-2*margin)+margin;
      const speed = (left?config.leftTemp:config.rightTemp) * (Math.random()*0.6+0.7)/50; 
      const ang=Math.random()*Math.PI*2;
      Module.particles[idx+2]=Math.cos(ang)*speed; 
      Module.particles[idx+3]=Math.sin(ang)*speed;
      Module.particles[idx+4]=0; 
      Module.particles[idx+5]=0; 
      Module.particles[idx+6]=0; 
      Module.particles[idx+7]=config.radius;
    }
    updateColors(); 
    Module.ready=true; 
    return Module;
  }

  function update(cfg){ 
    if(!Module.ready) return; 
    const dt = 1/60/cfg.substeps;
    
    // Update bond system
    BondSystem.enabled = cfg.nodeMode;
    // This now handles its own update frequency
    BondSystem.update(Module.particles, Module.particleCount, cfg);
    Module.bondChecks = BondSystem.getBondChecks();
    
    for(let s=0;s<cfg.substeps;s++){ 
      applyForces(dt,cfg); 
      // Apply bond forces after regular forces
      if (BondSystem.enabled) {
        BondSystem.applyBondForces(Module.particles, Module.particleCount, cfg, dt);
      }
      updatePositions(dt,cfg); 
      handleCollisions(cfg); 
    } 
    updateColors(); 
  }

  function applyForces(dt, cfg) {
    const p = Module.particles;
    const n = Module.particleCount;
    const EPS = 1e-8;
    const cellSize = cfg.gridSize;
    
    // Apply mouse forces if mouse is down
    if (mouseState.isDown) {
      const mouseX = mouseState.x;
      const mouseY = mouseState.y;
      const forceStrength = mouseState.forceStrength;
      
      for (let i = 0; i < n; i++) {
        const idx = i * 8;
        const px = p[idx];
        const py = p[idx + 1];
        
        const dx = px - mouseX;
        const dy = py - mouseY;
        const dist2 = dx * dx + dy * dy;
        
        if (dist2 > 1 && dist2 < 10000) { // Effect radius ~100px
          const dist = Math.sqrt(dist2);
          const nx = dx / dist;
          const ny = dy / dist;
          
          // Divergence force (radial)
          let radialForce = 0;
          if (cfg.divergenceInward) {
            radialForce = -forceStrength / dist; // Inward (negative = towards mouse)
          } else {
            radialForce = forceStrength / dist; // Outward (positive = away from mouse)
          }
          
          // Curl force (tangential)
          let tangentX = -ny; // Perpendicular to radial
          let tangentY = nx;
          if (!cfg.curlClockwise) {
            tangentX = ny; // Reverse for anticlockwise
            tangentY = -nx;
          }
          const curlForce = forceStrength / dist;
          
          // Combine forces
          const fx = nx * radialForce + tangentX * curlForce * 0.5;
          const fy = ny * radialForce + tangentY * curlForce * 0.5;
          
          p[idx + 2] += fx * dt * 0.1; // Scale down for reasonable effect
          p[idx + 3] += fy * dt * 0.1;
        }
      }
    }

    if (cfg.gravity || cfg.pressure) {
      clearSpatialGrid();
      for (let i = 0; i < n; i++) {
        const idx = i * 8;
        const x = p[idx], y = p[idx + 1];
        if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
        addToSpatialGrid(i, x, y, cellSize);
      }
    }

    // Auto-scaling force sampling logic (no longer a slider)
    let forceFraction = 1.0; // Default to 100%
    if (n > 5000) forceFraction = 0.02;//5% sampling default for many particles

    const forceParticleCount = Math.max(1, Math.floor(n * forceFraction));
    const forceStep = Math.max(1, Math.floor(n / forceParticleCount));
    const invFraction = 1 / forceFraction;
    const exponent = cfg.gravityExponent;
    const softening = 25;
	
    forceUpdateOffset = (forceUpdateOffset + 1) % forceStep;

    for (let i = 0; i < n; i++) {
      const idx = i * 8;
      let fx = 0, fy = 0;

      const vx0 = p[idx + 2], vy0 = p[idx + 3];
      const speed2 = vx0 * vx0 + vy0 * vy0;
      const maxSpeed2 = cfg.tunneling * cfg.tunneling;

      if (speed2 > maxSpeed2) {
        const scale = cfg.tunneling / Math.sqrt(speed2);
        p[idx + 2] *= scale;
        p[idx + 3] *= scale;
      }

      if (cfg.drag && speed2 > 1e-6) {
        const speed = Math.sqrt(speed2);
        const dragMag = cfg.dragCoeff * speed2;
        fx -= (p[idx + 2] / speed) * dragMag;
        fy -= (p[idx + 3] / speed) * dragMag;
      }

      const shouldCalculateExpensiveForces = (cfg.gravity || cfg.pressure) && 
                                            ((i + forceUpdateOffset) % forceStep === 0);
      
      if (shouldCalculateExpensiveForces) {
        const x = p[idx], y = p[idx + 1];
        if (!Number.isFinite(x) || !Number.isFinite(y)) {
          p[idx + 2] = 0; p[idx + 3] = 0;
        } else {
          const gx = Math.floor(x / cellSize);
          const gy = Math.floor(y / cellSize);
          if (Number.isFinite(gx) && Number.isFinite(gy)) {
            // Use cfg.gravityDistance for gravity range
            const gravityRange = cfg.gravity ? cfg.gravityDistance : 0;
            const pressureRange = cfg.pressure ? 1 : 0;
            const maxRange = Math.max(gravityRange, pressureRange);
			let gravForce = 0;
            for (let dx = -maxRange; dx <= maxRange; dx++) {
              for (let dy = -maxRange; dy <= maxRange; dy++) {
                const cellX = gx + dx;
                const cellY = gy + dy;
                if (cellX < 0 || cellX >= gridWidth || cellY < 0 || cellY >= gridHeight) continue;
                const cell = spatialGrid[cellY * gridWidth + cellX];
                if (!cell) continue;
                const cellDist2 = dx * dx + dy * dy;
				
                for (let k = 0; k < cell.length; k++) {
                  const j = cell[k];
                  if (i === j) continue;
                  const jdx = j * 8;
                  const dxp = p[jdx] - x;
                  const dyp = p[jdx + 1] - y;
                  const dist2 = dxp * dxp + dyp * dyp;
                  if(dist2 < 1) continue;
                  const invDist = 1 / Math.sqrt(dist2);
                  const nx = dxp * invDist;
                  const ny = dyp * invDist;
				  
				  const softenedDist2 = dist2 + softening*softening;

                  if (cfg.gravity && cellDist2 <= gravityRange * gravityRange) {
                    if (exponent == 2) {
                      gravForce = (cfg.gravityStrength * invFraction) / softenedDist2;
					} else {
                      const distPow = Math.pow(softenedDist2, exponent / 2);
					  gravForce = (cfg.gravityStrength * invFraction) / distPow;
	                }
                    fx += nx * gravForce;
                    fy += ny * gravForce;
                  }

                  if (cfg.pressure && cellDist2 <= pressureRange * pressureRange) {
                    const maxPressDist = p[idx + 7] * 8;
                    const dist = 1 / invDist;
                    if (dist < maxPressDist) {
                      const pressForce = (cfg.pressureStrength * invDist * invFraction * 0.6);
                      fx -= nx * pressForce;
                      fy -= ny * pressForce;
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (!Number.isFinite(fx)) fx = 0;
      if (!Number.isFinite(fy)) fy = 0;
      p[idx + 2] += fx * dt;
      p[idx + 3] += fy * dt;
    }
  }

  function updateParticleTemperatures(leftTemp, rightTemp) {
    if (!Module.ready) return;
    const p = Module.particles;
    const n = Module.particleCount;
    const cx = config.width * (config.wallPosition / 100);
    
    for (let i = 0; i < n; i++) {
      const idx = i * 8;
      const x = p[idx];
      const isLeft = x < cx;
      const currentSpeed = Math.sqrt(p[idx + 2] * p[idx + 2] + p[idx + 3] * p[idx + 3]);
      const targetTemp = isLeft ? leftTemp : rightTemp;
      const targetSpeed = targetTemp * (Math.random() * 0.6 + 0.7) / 50;
      
      if (currentSpeed > 0.1) {
        const speedRatio = targetSpeed / currentSpeed;
        const adjustmentFactor = 0.2;
        const newSpeedRatio = 1 + (speedRatio - 1) * adjustmentFactor;
        p[idx + 2] *= newSpeedRatio;
        p[idx + 3] *= newSpeedRatio;
      } else {
        const ang = Math.random() * Math.PI * 2;
        p[idx + 2] = Math.cos(ang) * targetSpeed;
        p[idx + 3] = Math.sin(ang) * targetSpeed;
      }
    }
  }

  // New: update only left or only right side temperatures (for independent sliders)
  function updateLeftParticleTemperatures(leftTemp) {
    if (!Module.ready) return;
    const p = Module.particles; const n = Module.particleCount;
    const cx = config.width * (config.wallPosition / 100);
    for (let i = 0; i < n; i++) {
      const idx = i * 8;
      const x = p[idx];
      if (x < cx) {
        const currentSpeed = Math.sqrt(p[idx + 2] * p[idx + 2] + p[idx + 3] * p[idx + 3]);
        const targetSpeed = leftTemp * (Math.random() * 0.6 + 0.7) / 50;
        if (currentSpeed > 0.1) {
          const speedRatio = targetSpeed / currentSpeed;
          const newSpeedRatio = 1 + (speedRatio - 1) * 0.2;
          p[idx + 2] *= newSpeedRatio; p[idx + 3] *= newSpeedRatio;
        } else {
          const ang = Math.random() * Math.PI * 2;
          p[idx + 2] = Math.cos(ang) * targetSpeed;
          p[idx + 3] = Math.sin(ang) * targetSpeed;
        }
      }
    }
  }
  function updateRightParticleTemperatures(rightTemp) {
    if (!Module.ready) return;
    const p = Module.particles; const n = Module.particleCount;
    const cx = config.width * (config.wallPosition / 100);
    for (let i = 0; i < n; i++) {
      const idx = i * 8;
      const x = p[idx];
      if (x >= cx) {
        const currentSpeed = Math.sqrt(p[idx + 2] * p[idx + 2] + p[idx + 3] * p[idx + 3]);
        const targetSpeed = rightTemp * (Math.random() * 0.6 + 0.7) / 50;
        if (currentSpeed > 0.1) {
          const speedRatio = targetSpeed / currentSpeed;
          const newSpeedRatio = 1 + (speedRatio - 1) * 0.2;
          p[idx + 2] *= newSpeedRatio; p[idx + 3] *= newSpeedRatio;
        } else {
          const ang = Math.random() * Math.PI * 2;
          p[idx + 2] = Math.cos(ang) * targetSpeed;
          p[idx + 3] = Math.sin(ang) * targetSpeed;
        }
      }
    }
  }

  function updatePositions(dt, cfg) {
    const p = Module.particles;
    const n = Module.particleCount;
    const w = cfg.width, h = cfg.height;
    const cx = w * (cfg.wallPosition / 100);
    const pipeTop = h / 2 - (cfg.pipeHeight / 100) * h / 2;
    const pipeBottom = h / 2 + (cfg.pipeHeight / 100) * h / 2;
    const wallT = 10;
    const demonThresholdSq = cfg.demonSpeedThreshold * cfg.demonSpeedThreshold;
    
    for (let i = 0; i < n; i++) {
        const idx = i * 8;
        let x = p[idx], y = p[idx + 1];
        let vx = p[idx + 2], vy = p[idx + 3];
        const r = p[idx + 7]/2;
        x += vx * dt;
        y += vy * dt;
        const restitution = 1;
        if (x - r < 0) { x = r; vx = Math.abs(vx) * restitution; }
        if (x + r > w) { x = w - r; vx = -Math.abs(vx) * restitution; }
        if (y - r < 0) { y = r; vy = Math.abs(vy) * restitution; }
        if (y + r > h) { y = h - r; vy = -Math.abs(vy) * restitution; }

        const leftWallEdge = cx - wallT/2;
        const rightWallEdge = cx + wallT/2;
        const isCrossingWall = (x > leftWallEdge && x < rightWallEdge) || 
                              (x + r > leftWallEdge && x < leftWallEdge) || 
                              (x - r < rightWallEdge && x > rightWallEdge);
        
        if (isCrossingWall) {
            const withinPipe = cfg.pipeOpen && (y >= pipeTop && y <= pipeBottom);
            let shouldBounce = false;
            if (cfg.maxwellDemon) {
                const speedSq = vx*vx + vy*vy;
                const isMovingRight = vx > 0;
                const isFastParticle = speedSq >= demonThresholdSq;
                if (isMovingRight && isFastParticle) {
                    teleportSlowParticle(p, n, cx, demonThresholdSq, 'rightToLeft');
                } else if (!isMovingRight && !isFastParticle) {
                    teleportFastParticle(p, n, cx, demonThresholdSq, 'leftToRight');
                } else {
                    shouldBounce = true;
                }
            } else if (!withinPipe) {
                shouldBounce = true;
            }
            if (shouldBounce) {
                if (x > leftWallEdge && x < rightWallEdge) {
                    const distToLeft = x - leftWallEdge;
                    const distToRight = rightWallEdge - x;
                    if (distToLeft < distToRight) {
                        x = leftWallEdge - r;
                        vx = -Math.abs(vx) * restitution;
                    } else {
                        x = rightWallEdge + r;
                        vx = Math.abs(vx) * restitution;
                    }
                } else if (x + r > leftWallEdge && x < leftWallEdge) {
                    x = leftWallEdge - r;
                    vx = -Math.abs(vx) * restitution;
                } else if (x - r < rightWallEdge && x > rightWallEdge) {
                    x = rightWallEdge + r;
                    vx = Math.abs(vx) * restitution;
                }
            }
        }
        p[idx] = x; p[idx + 1] = y;
        p[idx + 2] = vx; p[idx + 3] = vy;
    }
  }

  // HandleCollisions remains the same... (pasting for completeness of the block)
  const CollisionStats = { collisions:0, checks:0 };
  function handleCollisions(cfg){
    const p = Module.particles; 
    const n = Module.particleCount; 
    CollisionStats.collisions = 0; 
    CollisionStats.checks = 0;
    
    if(cfg.useSAP){
      const idxs = new Uint32Array(n);
      for(let i=0;i<n;i++) idxs[i]=i;
      const positions = new Float32Array(n);
      for(let i=0;i<n;i++) positions[i] = p[i*8];
      idxs.sort((a,b) => positions[a] - positions[b]);
      
      for(let i=0;i<n;i++){
        const a = idxs[i]*8;
        const ax = p[a], ay = p[a+1], ar = p[a+7];
        let collisionCount = 0;
        const maxCollisionsPerParticle = 8;
        
        for(let j=i+1;j<n && collisionCount < maxCollisionsPerParticle;j++){
          const b = idxs[j]*8;
          const bx = p[b];
          if(bx - p[b+7] > ax + ar) break;
          CollisionStats.checks++;
          const dx = bx - ax;
          const dy = p[b+1] - ay;
          const dist2 = dx*dx + dy*dy;
          const minD = (ar + p[b+7])/2;
          const minD2 = minD * minD;
          
          if(dist2 < minD2 && dist2 > 0.01){
            CollisionStats.collisions++;
            collisionCount++;
            const dist = Math.sqrt(dist2);
            const nx = dx / dist;
            const ny = dy / dist;
            const v1x = p[a+2], v1y = p[a+3];
            const v2x = p[b+2], v2y = p[b+3];
            const kx = v1x - v2x;
            const ky = v1y - v2y;
            const momentum = (nx * kx + ny * ky);
            if(cfg.friction) {
              const f = cfg.frictionCoeff;
              p[a+2] = (v1x - momentum * nx) * f;
              p[a+3] = (v1y - momentum * ny) * f;
              p[b+2] = (v2x + momentum * nx) * f;
              p[b+3] = (v2y + momentum * ny) * f;
            } else {
              p[a+2] = v1x - momentum * nx;
              p[a+3] = v1y - momentum * ny;
              p[b+2] = v2x + momentum * nx;
              p[b+3] = v2y + momentum * ny;
            }
            const overlap = minD - dist;
            const sep = Math.min(overlap * 0.6, minD * 0.2);
            p[a] -= nx * sep;
            p[a+1] -= ny * sep;
            p[b] += nx * sep;
            p[b+1] += ny * sep;
          }
        }
      }
    } else {
      const cell = Math.max(8, cfg.radius*3);
      const gw = Math.ceil(cfg.width/cell);
      const gh = Math.ceil(cfg.height/cell);
      const grid = new Array(gw*gh);
      for(let i=0;i<grid.length;i++) grid[i] = [];
      for(let i=0;i<n;i++){
        const idx=i*8;
        const gx=Math.floor(p[idx]/cell);
        const gy=Math.floor(p[idx+1]/cell);
        if(gx>=0&&gx<gw&&gy>=0&&gy<gh) grid[gy*gw+gx].push(i);
      }
      for(let g=0;g<grid.length;g++){
        const cellArr=grid[g];
        const cellSize = cellArr.length;
        if(cellSize > 250) continue;
        for(let a=0;a<cellSize;a++){
          for(let b=a+1;b<cellSize;b++){
            const ai=cellArr[a]*8, bi=cellArr[b]*8;
            CollisionStats.checks++;
            const dx=p[bi]-p[ai];
            const dy=p[bi+1]-p[ai+1];
            const dist2=dx*dx+dy*dy;
            const minD=(p[ai+7]+p[bi+7])/2;
            const minD2 = minD*minD;
            if(dist2<minD2 && dist2>0.01){
              CollisionStats.collisions++;
              const dist = Math.sqrt(dist2);
              const nx = dx / dist;
              const ny = dy / dist;
              const v1x = p[ai+2], v1y = p[ai+3];
              const v2x = p[bi+2], v2y = p[bi+3];
              const kx = v1x - v2x;
              const ky = v1y - v2y;
              const momentum = (nx * kx + ny * ky);
              if(cfg.friction) {
                const f = cfg.frictionCoeff;
                p[ai+2] = (v1x - momentum * nx) * f;
                p[ai+3] = (v1y - momentum * ny) * f;
                p[bi+2] = (v2x + momentum * nx) * f;
                p[bi+3] = (v2y + momentum * ny) * f;
              } else {
                p[ai+2] = v1x - momentum * nx;
                p[ai+3] = v1y - momentum * ny;
                p[bi+2] = v2x + momentum * nx;
                p[bi+3] = v2y + momentum * ny;
              }
              const overlap = minD - dist;
              const sep = Math.min(overlap * 0.6, minD * 0.2);
              p[ai] -= nx * sep;
              p[ai+1] -= ny * sep;
              p[bi] += nx * sep;
              p[bi+1] += ny * sep;
            }
          }
        }
      }
    }
    Module.collisionStats = { collisions: CollisionStats.collisions, checks: CollisionStats.checks };
  }

  let lastColorUpdate = 0;
  function updateColors(){ 
    const now = performance.now();
    if(now - lastColorUpdate < 33) return; // optimize: update colors ~30fps to reduce overhead
    lastColorUpdate = now;
    const p=Module.particles, n=Module.particleCount; 
    for(let i=0;i<n;i++){ 
      const idx=i*8; 
      const speed2 = p[idx+2]*p[idx+2] + p[idx+3]*p[idx+3];
      const speed = Math.sqrt(speed2);
      const hue = 240-Math.min(speed*6,240); 
      const rgb=hslToRgb(hue/360,1,0.5); 
      p[idx+4]=rgb[0]; 
      p[idx+5]=rgb[1]; 
      p[idx+6]=rgb[2]; 
    }
  }

  return { 
    init, 
    update, 
    updateParticleTemperatures,
    updateLeftParticleTemperatures,
    updateRightParticleTemperatures,
    updateParticleCount,
    reinitGrid: ()=>reinitGrid(config.width, config.height, config.gridSize), // Expose grid re-init
    get particles(){return Module.particles;}, 
    get particleCount(){return Module.particleCount;}, 
    get collisionStats(){return Module.collisionStats||{collisions:0,checks:0}}, 
    ready:()=>Module.ready,
    get bondChecks(){return Module.bondChecks||0}
  };
})();

// ---------- Optimized Rendering ----------
function renderParticlesToWebGL(particles, count){ 
  if(!gl){ 
    // Optimized 2D fallback - batch operations
    const ctx = canvas.getContext('2d'); 
    ctx.clearRect(0,0,canvas.width,canvas.height);
    
    // Use ImageData for better performance with many particles
    if(count > 20000) {
      const imageData = ctx.createImageData(canvas.width, canvas.height);
      const data = imageData.data;
      
      for(let i=0;i<count;i++){
        const idx=i*8;
        const x = Math.floor(particles[idx]);
        const y = Math.floor(particles[idx+1]);
        const r = Math.floor(particles[idx+7]);
        
        if(x >= 0 && x < canvas.width && y >= 0 && y < canvas.height) {
          const pixelIdx = (y * canvas.width + x) * 4;
          if(pixelIdx < data.length) {
            data[pixelIdx] = particles[idx+4] * 255;     // R
            data[pixelIdx+1] = particles[idx+5] * 255;   // G
            data[pixelIdx+2] = particles[idx+6] * 255;   // B
            data[pixelIdx+3] = 255;                      // A
          }
        }
      }
      
      ctx.putImageData(imageData, 0, 0);
    } else {
      // Regular canvas drawing for smaller counts
      ctx.globalCompositeOperation = 'lighter'; // additive blending for glow effect
      for(let i=0;i<count;i++){ 
        const idx=i*8; 
        const x=particles[idx], y=particles[idx+1], r=particles[idx+7]; 
        const rgb=[particles[idx+4]*255,particles[idx+5]*255,particles[idx+6]*255]; 
        ctx.fillStyle = `rgb(${rgb[0]|0},${rgb[1]|0},${rgb[2]|0})`; 
        ctx.beginPath(); 
        ctx.arc(x,y,r,0,Math.PI*2); 
        ctx.fill(); 
      }
      ctx.globalCompositeOperation = 'source-over';
    }
    return; 
  }

  // Optimized WebGL upload - reuse buffers when possible
  const pos = new Float32Array(count*2); 
  const cols = new Float32Array(count*3); 
  const rads = new Float32Array(count);
  
  // Batch copy data
  for(let i=0;i<count;i++){ 
    const idx=i*8; 
    const i2 = i*2, i3 = i*3;
    pos[i2]=particles[idx]; 
    pos[i2+1]=particles[idx+1]; 
    cols[i3]=particles[idx+4]; 
    cols[i3+1]=particles[idx+5]; 
    cols[i3+2]=particles[idx+6]; 
    rads[i]=particles[idx+7]; 
  }

  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.useProgram(program);
  
  const posLoc = gl.getAttribLocation(program,'a_position'); 
  const colLoc = gl.getAttribLocation(program,'a_color'); 
  const radLoc = gl.getAttribLocation(program,'a_radius');
  const resLoc = gl.getUniformLocation(program,'u_resolution'); 
  const prLoc = gl.getUniformLocation(program,'u_pixelRatio');

  // Upload buffers efficiently
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); 
  gl.bufferData(gl.ARRAY_BUFFER, pos, gl.STREAM_DRAW); // STREAM_DRAW for dynamic data
  gl.enableVertexAttribArray(posLoc); 
  gl.vertexAttribPointer(posLoc,2,gl.FLOAT,false,0,0);

  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer); 
  gl.bufferData(gl.ARRAY_BUFFER, cols, gl.STREAM_DRAW);
  gl.enableVertexAttribArray(colLoc); 
  gl.vertexAttribPointer(colLoc,3,gl.FLOAT,false,0,0);

  gl.bindBuffer(gl.ARRAY_BUFFER, radiusBuffer); 
  gl.bufferData(gl.ARRAY_BUFFER, rads, gl.STREAM_DRAW);
  gl.enableVertexAttribArray(radLoc); 
  gl.vertexAttribPointer(radLoc,1,gl.FLOAT,false,0,0);

  gl.uniform2f(resLoc, config.width, config.height); 
  gl.uniform1f(prLoc, devicePixelRatio || 1);
  gl.drawArrays(gl.POINTS, 0, count);
}

// ---------- UI helpers & graphs ----------
function pushHistory(l, r){ 
  if (graphManager) graphManager.pushHistory(l, r);
}

function drawWalls() {
  const o = document.getElementById('overlay');
  const ctx = o.getContext('2d');
  const W = o.width, H = o.height;
  const cx = W * (config.wallPosition / 100); // use wallPosition
  const pipePct = config.pipeHeight * 0.01;
  const pipeOpen = config.pipeOpen;   // true/false
  const openH = Math.max(2, Math.floor(H * pipePct));
  const wallThickness = Math.max(2, Math.floor(Math.min(W, H) * 0.003));

  ctx.clearRect(0, 0, W, H);

  // divider
  ctx.strokeStyle = '#999'; // matches background

  ctx.fillStyle   = '#ff4040';
  ctx.lineWidth   = wallThickness;
  ctx.beginPath();
  ctx.moveTo(cx, 0);
  ctx.lineTo(cx, H);
  ctx.stroke();

  if (pipeOpen && openH > 0) {
    const y0 = Math.floor((H - openH) / 2);
    const y1 = y0 + openH;

    ctx.strokeStyle = '#0f0f0f'; // background
    ctx.lineWidth = wallThickness * 1.8;
    ctx.beginPath();
    ctx.moveTo(cx, y0);
    ctx.lineTo(cx, y1);
    ctx.stroke();

    ctx.fillStyle = '#ffeb3b';
    ctx.fillRect(cx - wallThickness, y0 - wallThickness, wallThickness * 2, wallThickness);
    ctx.fillRect(cx - wallThickness, y1, wallThickness * 2, wallThickness);
  }
}


function drawMiniGraph(canvasEl, data, autoScale=true){ 
  const ctx = canvasEl.getContext('2d'); 
  const W=canvasEl.width, H=canvasEl.height; 
  ctx.clearRect(0,0,W,H); 
  if(data.length<2) return; 
  let min=Math.min(...data), max=Math.max(...data); 
  if(!autoScale){ min=0; } 
  const pad=6; 
  const plotH=H-2*pad; 
  const plotW=W-2*pad; 
  const range = (max-min)||1; 
  ctx.beginPath(); 
  for(let i=0;i<data.length;i++){ 
    const x = pad + (i/(data.length-1))*plotW; 
    const y = pad + (1 - (data[i]-min)/range)*plotH; 
    if(i===0) ctx.moveTo(x,y); 
    else ctx.lineTo(x,y); 
  } 
  ctx.strokeStyle='rgba(0,255,136,0.9)'; 
  ctx.lineWidth=1.5; 
  ctx.stroke(); 
}

function colorStat(leftId, rightId, leftVal, rightVal) {
  const leftEl = document.getElementById(leftId);
  const rightEl = document.getElementById(rightId);

  if (leftVal > rightVal) {
    leftEl.style.color = "limegreen";
    rightEl.style.color = "red";
  } else if (rightVal > leftVal) {
    rightEl.style.color = "limegreen";
    leftEl.style.color = "red";
  } else {
    leftEl.style.color = "#ccc";
    rightEl.style.color = "#ccc";
  }
}


function updateStatsDOM(){ 
  document.getElementById('fps').textContent = Math.round(stats.fps); 
  document.getElementById('targetFps').textContent = config.uncapFps ? Math.round(targetFps) : '60';
  document.getElementById('collisionRate').textContent=Math.round(stats.collisionRate); 
  document.getElementById('collisionChecks').textContent=Math.round(stats.collisionChecks); 
  document.getElementById('totalParticles').textContent=stats.totalParticles; // Now live
  document.getElementById('bondChecks').textContent = stats.bondChecks || 0; // Show bond checks instead of render mode
  document.getElementById('leftBoxTemp').textContent=(stats.leftBoxTemp || 0).toFixed(2); 
  document.getElementById('rightBoxTemp').textContent=(stats.rightBoxTemp || 0).toFixed(2);
  // NEW STATS
  document.getElementById('leftAvgSpeed').textContent=(stats.leftAvgSpeed || 0).toFixed(2);
  document.getElementById('rightAvgSpeed').textContent=(stats.rightAvgSpeed || 0).toFixed(2);
  document.getElementById('leftMaxSpeed').textContent=(stats.leftMaxSpeed || 0).toFixed(2);
  document.getElementById('rightMaxSpeed').textContent=(stats.rightMaxSpeed || 0).toFixed(2);
  // Bond stats
  document.getElementById('totalBonds').textContent = stats.totalBonds;
  document.getElementById('avgBondsPerParticle').textContent = (stats.avgBondsPerParticle || 0).toFixed(2);
    // Compare all left/right stat pairs
  colorStat("leftBoxTemp",   "rightBoxTemp",   stats.leftBoxTemp,   stats.rightBoxTemp);
  colorStat("leftAvgSpeed",  "rightAvgSpeed",  stats.leftAvgSpeed,  stats.rightAvgSpeed);
  colorStat("leftMaxSpeed",  "rightMaxSpeed",  stats.leftMaxSpeed,  stats.rightMaxSpeed);

  if(Math.random() < 1) {
    if (graphManager) graphManager.drawAll();
  }
}

// ---------- Optimized main loop with TRUE FPS uncapping ----------
let frameCount = 0;
let physicsLoopId = null; // To hold the reference to our setInterval
let adaptiveFpsIntervalId = null; // To hold the adaptive FPS adjuster

let physicsTicks = 0;
let physicsFps = 0;

// measure physics loop rate every second
setInterval(() => {
  physicsFps = physicsTicks;
  physicsTicks = 0;
  document.getElementById("physicsFps").textContent = physicsFps;
}, 1000);

// The NEW physics-only loop
function physicsLoop() {
  if (!isRunning) return;
  physicsTicks++;
  // Get bond checks from the physics module AFTER it updates
  PhysicsModule.update(config);
  stats.bondChecks = PhysicsModule.bondChecks;

  if (frameCount % 3 === 0) {
    const particles = PhysicsModule.particles;
    const count = PhysicsModule.particleCount;
    let leftSum = 0, leftCount = 0, rightSum = 0, rightCount = 0;
    let leftSumSpeed = 0, rightSumSpeed = 0;
    let leftMaxSpeed = 0, rightMaxSpeed = 0;
    let validParticleCount = 0;
    const cx = config.width * (config.wallPosition / 100);

    for (let i = 0; i < count; i++) {
      const idx = i * 8;
      // Check for valid particles
      if (!Number.isFinite(particles[idx])) continue;
      validParticleCount++;
      
      const sp2 = particles[idx + 2] * particles[idx + 2] + particles[idx + 3] * particles[idx + 3];
      const speed = Math.sqrt(sp2);

      if (particles[idx] < cx) {
        leftSum += sp2;
        leftSumSpeed += speed;
        if (speed > leftMaxSpeed) leftMaxSpeed = speed;
        leftCount++;
      } else {
        rightSum += sp2;
        rightSumSpeed += speed;
        if (speed > rightMaxSpeed) rightMaxSpeed = speed;
        rightCount++;
      }
    }

    stats.leftBoxTemp = leftCount ? Math.sqrt(leftSum / leftCount) : 0;
    stats.rightBoxTemp = rightCount ? Math.sqrt(rightSum / rightCount) : 0;
    stats.leftAvgSpeed = leftCount ? leftSumSpeed / leftCount : 0;
    stats.rightAvgSpeed = rightCount ? rightSumSpeed / rightCount : 0;
    stats.leftMaxSpeed = leftMaxSpeed;
    stats.rightMaxSpeed = rightMaxSpeed;
    stats.totalParticles = validParticleCount; // Update live count
    
    // Update bond statistics
    stats.totalBonds = BondSystem.bonds.length;
    stats.avgBondsPerParticle = validParticleCount > 0 ? (stats.totalBonds * 2) / validParticleCount : 0;
    
    pushHistory(stats.leftBoxTemp, stats.rightBoxTemp);
  }

  stats.collisionChecks = PhysicsModule.collisionStats ? PhysicsModule.collisionStats.checks : 0;
  stats.collisionRate = PhysicsModule.collisionStats ? PhysicsModule.collisionStats.collisions : 0;
}


// The MODIFIED main loop is now for rendering ONLY
function mainLoop(ts) {
  // We still request a new frame to keep the rendering loop going
  requestAnimationFrame(mainLoop);

  // But we respect the pause button for rendering
  if (!isRunning) {
    lastRAF = ts;
    return;
  }

  const dt = (ts - lastRAF) / 1000;
  lastRAF = ts;
  
  // Avoid massive dt values if the tab was inactive
  if (dt > 0.1) return; 

  const currentFps = 1 / dt;
  fpsSmooth = fpsSmooth * 0.95 + currentFps * 0.05;
  stats.fps = fpsSmooth;

  // --- Physics update is REMOVED from here ---

// Render the latest state of the particles
renderer.render(PhysicsModule.particles, PhysicsModule.particleCount);


// Draw the overlay wall
renderer.drawWalls();

// Render bonds on overlay canvas
if (config.nodeMode) {
  const overlayCtx = overlay.getContext('2d');
  BondSystem.render(overlayCtx, PhysicsModule.particles, PhysicsModule.particleCount);
}


  // Update UI less frequently
  if (frameCount % 5 === 0) {
    updateStatsDOM();
  }

  frameCount++;
}


// ---------- UI wiring ----------
function wireUI(){ 
  const set=(id,cb,fmt)=>{ 
    const el=document.getElementById(id); 
    const lab=document.getElementById(id+'Value'); 
    const upd=()=>lab.textContent=fmt?fmt(el.value):el.value; 
    el.addEventListener('input',()=>{ cb(el.value); upd(); }); 
    upd(); 
  };
  
  const updateParticleSliderMax = () => {
  const slider = document.getElementById('particleCount');
  const valueDisplay = document.getElementById('particleCountValue');
  
  if (config.nodeMode) {
    slider.max = 500;
    // If current count exceeds 500, reduce it immediately
    if (config.particleCount > 500) {
      config.particleCount = 500;
      slider.value = 500;
      valueDisplay.textContent = 500;
      // Actually update the physics module with the new count
      PhysicsModule.updateParticleCount(config.particleCount);
    }
  } else {
    slider.max = 100000;
  }
};
  
  set('particleCount', v=>{ 
    config.particleCount=Number(v); 
    if(PhysicsModule.ready()) {
      PhysicsModule.updateParticleCount(config.particleCount);
    }
  }, v=>v);
  
  set('leftTemp', v=> {
    config.leftTemp=Number(v);
    PhysicsModule.updateLeftParticleTemperatures(config.leftTemp);
  }, v=>v);
  set('rightTemp', v=> {
    config.rightTemp=Number(v);
    PhysicsModule.updateRightParticleTemperatures(config.rightTemp);
  }, v=>v);
  
  set('radius', v=> { 
    config.radius=Number(v); 
    if(PhysicsModule.particles) {
      const newRadius = config.radius;
      for(let i=0;i<PhysicsModule.particleCount;i++) {
        PhysicsModule.particles[i*8+7]=newRadius;
      }
    }
  }, v=>v+'px');
  set('pipeHeight', v=> config.pipeHeight=Number(v), v=>v+'%');
  set('substeps', v=> config.substeps=Math.max(1,Number(v)), v=>v);
  set('demonThreshold', v=> config.demonSpeedThreshold=Number(v), v=>v);
  set('pressureStrength', v=> config.pressureStrength=Number(v), v=>v);
  set('dragCoeff', v=> config.dragCoeff=Number(v), v=>Number(v).toFixed(4));
  
  // Gravity controls
  set('gravityStrength', v=> config.gravityStrength=Number(v), v=>v);
  set('gravityExponent', v=> config.gravityExponent=Number(v), v=>Number(v).toFixed(1));

  // --- NEW SLIDERS ---
  set('gravityDistance', v=> config.gravityDistance=Number(v), v=>v);
  set('wallPosition', v => {
  const newPos = Number(v);
  const oldPos = config.wallPosition;
  if (PhysicsModule.particles && oldPos !== newPos) {
    const p = PhysicsModule.particles;
    const n = PhysicsModule.particleCount;
    const oldCx = config.width * (oldPos / 100);
    const newCx = config.width * (newPos / 100);

    for (let i = 0; i < n; i++) {
      const idx = i * 8;
      let x = p[idx];

      if (x < oldCx) {
        // Scale into new left region
        const scale = newCx / oldCx;
        p[idx] = x * scale;
      } else {
        // Scale into new right region
        const oldRightWidth = config.width - oldCx;
        const newRightWidth = config.width - newCx;
        const rel = (x - oldCx) / oldRightWidth;
        p[idx] = newCx + rel * newRightWidth;
      }
    }
  }
  config.wallPosition = newPos;
}, v => v + '%');

  set('gridSize', v=> {
      config.gridSize=Number(v);
      if(PhysicsModule.ready()) PhysicsModule.reinitGrid();
  }, v=>v+'px');

  // --- REMOVED SLIDERS ---
  // 'tunneling' (Max Speed) and 'forceSampling' are no longer wired to the UI.
  
  document.getElementById('collisionMode').addEventListener('change', (e)=>{ 
    config.useSAP = e.target.checked; 
    document.getElementById('collisionModeLabel').textContent = config.useSAP?'SAP':'Grid'; 
  });
  
  document.getElementById('gravityToggle').addEventListener('change', (e)=>{ 
    config.gravity = e.target.checked; 
    document.getElementById('gravityLabel').textContent = config.gravity?'On':'Off'; 
  });
  document.getElementById('frictionToggle').addEventListener('change', (e)=>{ 
    config.friction = e.target.checked; 
    document.getElementById('frictionLabel').textContent = config.friction?'On':'Off'; 
  });
  document.getElementById('dragToggle').addEventListener('change', (e)=>{ 
    config.drag = e.target.checked; 
    document.getElementById('dragLabel').textContent = config.drag?'On':'Off'; 
  });
  document.getElementById('pressureToggle').addEventListener('change', (e)=>{ 
    config.pressure = e.target.checked; 
    document.getElementById('pressureLabel').textContent = config.pressure?'On':'Off'; 
  });
  
  document.getElementById('maxwellToggle').addEventListener('change', (e)=>{
    config.maxwellDemon = e.target.checked;
    document.getElementById('maxwellLabel').textContent = config.maxwellDemon ? 'On' : 'Off';
  });
  
  document.getElementById('uncapFpsToggle').addEventListener('change', (e) => {
    config.uncapFps = e.target.checked;
    document.getElementById('uncapFpsLabel').textContent = config.uncapFps ? 'On' : 'Off';
    if (physicsLoopId) clearInterval(physicsLoopId);
    if (adaptiveFpsIntervalId) clearInterval(adaptiveFpsIntervalId);
    if (config.uncapFps) {
      targetFps = 60;
      const adjustFps = () => {
        if (isRunning && config.uncapFps && targetFps < 240) { 
            targetFps += 10;
            clearInterval(physicsLoopId);
            physicsLoopId = setInterval(physicsLoop, 1000 / targetFps);
        }
      };
      physicsLoopId = setInterval(physicsLoop, 1000 / targetFps);
      adaptiveFpsIntervalId = setInterval(adjustFps, 100);
    } else {
      targetFps = 60;
      physicsLoopId = setInterval(physicsLoop, 1000 / 60);
    }
  });
  
  document.getElementById('divergenceToggle').addEventListener('change', (e) => {
    config.divergenceInward = e.target.checked;
    const label = document.getElementById('divergenceLabel');
    if (config.divergenceInward) {
      label.textContent = 'Inward';
      label.style.color = '#22c55e';
    } else {
      label.textContent = 'Outward';
      label.style.color = '#3b82f6';
    }
  });
  
  document.getElementById('curlToggle').addEventListener('change', (e) => {
    config.curlClockwise = e.target.checked;
    const label = document.getElementById('curlLabel');
    if (config.curlClockwise) {
      label.textContent = 'Clockwise';
      label.style.color = '#22c55e';
    } else {
      label.textContent = 'Anticlockwise';
      label.style.color = '#facc15';
    }
  });
  
  document.getElementById('nodeToggle').addEventListener('change', (e) => {
  config.nodeMode = e.target.checked;
  const label = document.getElementById('nodeLabel');
  
  // Call this BEFORE updating the UI
  updateParticleSliderMax();
  
  label.textContent = config.nodeMode ? 'On' : 'Off';
  label.style.color = config.nodeMode ? '#22c55e' : '#7A5836';
  
  if (!config.nodeMode) {
    BondSystem.clear();
  }
});
  
  set('nodeBranches', v => {
    const val = Number(v);
    config.nodeBranches = val === 11 ? -1 : val; // 11 = "All"
  }, v => Number(v) === 11 ? 'All' : v);
  
  set('nodeMaxDist', v => {
    const val = Number(v);
    config.nodeMaxDist = val;
    // Update nodeMinDist slider max to match current nodeMaxDist
    const minSlider = document.getElementById('nodeMinDist');
    minSlider.max = val;
    // Ensure nodeMinDist doesn't exceed nodeMaxDist
    if (config.nodeMinDist > val) {
      config.nodeMinDist = val;
      minSlider.value = val;
      document.getElementById('nodeMinDistValue').textContent = val + 'px';
    }
  }, v => Number(v) === 2000 ? '∞' : v + 'px');
  
  set('nodeMinDist', v => {
    const val = Number(v);
    config.nodeMinDist = val;
    // Update nodeMaxDist slider min to match current nodeMinDist
    const maxSlider = document.getElementById('nodeMaxDist');
    maxSlider.min = val;
    // Ensure nodeMaxDist doesn't go below nodeMinDist
    if (config.nodeMaxDist < val) {
      config.nodeMaxDist = val;
      maxSlider.value = val;
      document.getElementById('nodeMaxDistValue').textContent = val + 'px';
    }
  }, v => v + 'px');
  
  set('bondStiffness', v => {
    // Logarithmic scale: -2 to 1 maps to 0.01 to 10
    const logVal = Number(v);
    config.bondStiffness = Math.pow(10, logVal);
  }, v => Math.pow(10, Number(v)).toFixed(2));
  
  document.getElementById('bondDynamicsToggle').addEventListener('change', (e) => {
    config.bondDynamics = e.target.checked;
    const label = document.getElementById('bondDynamicsLabel');
    label.textContent = config.bondDynamics ? 'On' : 'Off';
    label.style.color = config.bondDynamics ? '#22c55e' : '#7A5836';
  });

  document.getElementById('resetBtn').addEventListener('click', ()=>{ 
    PhysicsModule.init(config.particleCount);
    resetGraphs();
  });
  document.getElementById('pauseBtn').addEventListener('click', (e)=>{ 
    isRunning = !isRunning; 
    e.target.textContent = isRunning? 'Pause':'Resume'; 
  });
  document.getElementById('pipeBtn').addEventListener('click', (e)=>{ 
    config.pipeOpen = !config.pipeOpen; 
    e.target.textContent = config.pipeOpen ? 'Close Pipe' : 'Open Pipe';
  });
}

// Mouse event handlers for particle interaction
canvas.addEventListener('mousedown', (e) => {
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  mouseState.isDown = true;
  mouseState.x = (e.clientX - rect.left) * dpr;
  mouseState.y = (e.clientY - rect.top) * dpr;
});

canvas.addEventListener('mousemove', (e) => {
  if (mouseState.isDown) {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    mouseState.x = (e.clientX - rect.left) * dpr;
    mouseState.y = (e.clientY - rect.top) * dpr;
  }
});

canvas.addEventListener('mouseup', () => {
  mouseState.isDown = false;
});

canvas.addEventListener('mouseleave', () => {
  mouseState.isDown = false;
});

// Touch event handlers for mobile support
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  const touch = e.touches[0];
  mouseState.isDown = true;
  mouseState.x = (touch.clientX - rect.left) * dpr;
  mouseState.y = (touch.clientY - rect.top) * dpr;
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (mouseState.isDown && e.touches.length > 0) {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const touch = e.touches[0];
    mouseState.x = (touch.clientX - rect.left) * dpr;
    mouseState.y = (touch.clientY - rect.top) * dpr;
  }
}, { passive: false });

canvas.addEventListener('touchend', () => {
  mouseState.isDown = false;
});

wireUI();
bindTooltips();
// Initialize physics and start
document.getElementById('loading').textContent = 'Seeding particles...';
PhysicsModule.init(config.particleCount);

// Start the default capped physics loop (60Hz)
if (!physicsLoopId) {
    physicsLoopId = setInterval(physicsLoop, 1000 / 60);
}

document.getElementById('loading').style.display = 'none';

// Start the rendering loop
requestAnimationFrame(mainLoop);

</script>

</body></html>
