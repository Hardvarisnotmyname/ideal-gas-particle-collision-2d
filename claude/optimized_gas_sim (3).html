<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MAXIMUM SPEED Gas Simulation</title>
  <meta name="viewport" content="width=1200, initial-scale=1.0">
  <style>
    body { background: #111; color: #fff; font-family: Arial, sans-serif; margin: 0; padding: 0;}
    .container { max-width: 1500px; margin: 0 auto;}
    .controls { display: flex; flex-wrap: wrap; gap: 20px; align-items: center; margin: 20px 0; }
    .controls label { font-size: 14px; }
    .controls input[type="range"] { width: 120px; }
    .stats, .temp-display { display: flex; gap: 24px; margin-bottom: 8px; }
    .canvas-row { display: flex; gap: 24px; }
    canvas { background: black; border: 2px solid #333; border-radius: 12px;}
    .btn { background: #333; color: #fff; border: none; border-radius: 5px; padding: 8px 20px; cursor: pointer; font-size: 14px;}
    .btn:hover { background: #555;}
    .graph-title { text-align: center; font-size: 13px; }
    .perf-info { color: #f00; font-size: 12px; margin-bottom: 10px; }
  </style>
</head>
<body>
<div class="container">
  <h1>MAXIMUM SPEED Gas Simulation <span style="font-size:16px;color:#f00;">[LUDICROUS MODE]</span></h1>
  
  <div class="perf-info">
    <div>OPTIMIZATIONS: No substepping | Minimal collision checks | Batched drawing | Reduced precision</div>
  </div>
  
  <div class="controls">
    <label>Particles/Box: <input id="nRange" type="range" min="10" max="100000" value="10000"><span id="nLabel">10000</span></label>
    <label>Temp Left: <input id="tLRange" type="range" min="0" max="1200" value="300"><span id="tLLabel">300</span></label>
    <label>Temp Right: <input id="tRRange" type="range" min="0" max="1200" value="100"><span id="tRLabel">100</span></label>
    <label>Radius: <input id="rRange" type="range" min="1" max="8" value="1"><span id="rLabel">1</span></label>
    <label>Pipe Height: <input id="pipeRange" type="range" min="30" max="600" value="100"><span id="pipeLabel">100</span></label>
    <button class="btn" id="resetBtn">Reset</button>
    <button class="btn" id="pauseBtn">Pause</button>
    <button class="btn" id="openWallBtn">Open Pipe</button>
  </div>
  
  <div class="controls">
    <button class="btn" id="gravityBtn">Gravity: OFF</button>
    <label>Gravity Strength: <input id="gravityRange" type="range" min="0" max="1" step="0.0001" value="0.0001"><span id="gravityLabel">0.0001</span></label>
    <button class="btn" id="frictionBtn">Friction: OFF</button>
    <label>Friction: <input id="frictionRange" type="range" min="0" max="0.05" step="0.005" value="0.01"><span id="frictionLabel">0.01</span></label>
  </div>
  
  <div class="temp-display">
    <div style="color:#ffa;">Left Temp: <span id="leftTemp">0</span></div>
    <div style="color:#aaf;">Right Temp: <span id="rightTemp">0</span></div>
  </div>
  <div class="stats">
    <div>Total Particles: <span id="totalParticles">0</span></div>
    <div>Collisions/sec: <span id="collisionRate">0</span></div>
    <div>FPS: <span id="fps">0</span></div>
  </div>
  
  <div class="canvas-row">
    <canvas id="simCanvas" width="1200" height="600"></canvas>
    <div>
      <div class="graph-title" style="color:#ffa;">Left Box Temperature</div>
      <canvas id="leftGraph" width="200" height="100"></canvas>
      <div class="graph-title" style="color:#aaf;">Right Box Temperature</div>
      <canvas id="rightGraph" width="200" height="100"></canvas>
    </div>
  </div>
</div>

<script>
/* --- Globals --- */
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const leftGraph = document.getElementById('leftGraph').getContext('2d');
const rightGraph = document.getElementById('rightGraph').getContext('2d');

// Cache DOM elements
const nRange = document.getElementById('nRange');
const tLRange = document.getElementById('tLRange');
const tRRange = document.getElementById('tRRange');
const rRange = document.getElementById('rRange');
const pipeRange = document.getElementById('pipeRange');
const nLabel = document.getElementById('nLabel');
const tLLabel = document.getElementById('tLLabel');
const tRLabel = document.getElementById('tRLabel');
const rLabel = document.getElementById('rLabel');
const pipeLabel = document.getElementById('pipeLabel');
const resetBtn = document.getElementById('resetBtn');
const pauseBtn = document.getElementById('pauseBtn');
const openWallBtn = document.getElementById('openWallBtn');
const gravityBtn = document.getElementById('gravityBtn');
const gravityRange = document.getElementById('gravityRange');
const gravityLabel = document.getElementById('gravityLabel');
const frictionBtn = document.getElementById('frictionBtn');
const frictionRange = document.getElementById('frictionRange');
const frictionLabel = document.getElementById('frictionLabel');
const leftTempDisplay = document.getElementById('leftTemp');
const rightTempDisplay = document.getElementById('rightTemp');
const totalParticlesDisplay = document.getElementById('totalParticles');
const collisionRateDisplay = document.getElementById('collisionRate');
const fpsDisplay = document.getElementById('fps');

// State
let paused = false, wallOpen = false, gravityOn = false, frictionOn = false;
let particles = [], sortedParticles = [];
let pipeHeight = 100;
let gravityStrength = 0.0001, frictionAmount = 0.01;
let collisionCount = 0, lastCollisionCount = 0, frameCount = 0, lastFpsTime = 0;
let leftTempHistory = [], rightTempHistory = [];
const maxGraphPoints = 50; // Reduced for speed

// Constants
const TEMP_SPEED_FACTOR = 0.025;
const leftBoxW = canvas.width * 0.5;
const rightBoxX = canvas.width * 0.5;
const canvasW = canvas.width;
const canvasH = canvas.height;
const TWO_PI = 6.283185307179586;

/* --- Ultra-Fast Particle Class --- */
function Particle(x, y, vx, vy, r) {
  this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.r = r;
}

Particle.prototype.update = function() {
  // Gravitational attraction to other particles
  if(gravityOn) {
    for(let i = 0; i < particles.length; i++) {
      const other = particles[i];
      if(other === this) continue;
      
      const dx = other.x - this.x;
      const dy = other.y - this.y;
      const distSq = dx * dx + dy * dy;
      
      if(distSq > 0.1) { // Avoid division by zero and extreme forces
        const force = gravityStrength / distSq;
        const dist = Math.sqrt(distSq);
        const fx = (dx / dist) * force;
        const fy = (dy / dist) * force;
        
        this.vx += fx;
        this.vy += fy;
      }
    }
  }
  
  // Direct position update
  this.x += this.vx;
  this.y += this.vy;
  
  // Boundary collisions
  if(this.x <= this.r) { this.x = this.r; this.vx = -this.vx; }
  else if(this.x >= canvasW - this.r) { this.x = canvasW - this.r; this.vx = -this.vx; }
  
  if(this.y <= this.r) { this.y = this.r; this.vy = -this.vy; }
  else if(this.y >= canvasH - this.r) { this.y = canvasH - this.r; this.vy = -this.vy; }
  
  // Center wall
  if(Math.abs(this.x - leftBoxW) <= this.r) {
    const pipeTop = (canvasH - pipeHeight) * 0.5;
    const withinPipe = this.y > pipeTop && this.y < pipeTop + pipeHeight;
    
    if(!wallOpen || !withinPipe) {
      this.x = this.vx > 0 ? leftBoxW - this.r : leftBoxW + this.r;
      this.vx = -this.vx;
    }
  }
};

/* --- Minimal Collision Detection --- */
function collisionDetection() {
  // Reuse array to avoid GC
  const len = particles.length;
  if(sortedParticles.length !== len) sortedParticles = new Array(len);
  
  // Copy and sort
  for(let i = 0; i < len; i++) sortedParticles[i] = particles[i];
  sortedParticles.sort((a, b) => a.x - b.x);
  
  for(let i = 0; i < len - 1; i++) {
    const a = sortedParticles[i];
    const maxX = a.x + a.r;
    
    for(let j = i + 1; j < len; j++) {
      const b = sortedParticles[j];
      if(b.x - a.r > maxX) break;
      
      const dy = b.y - a.y;
      if(Math.abs(dy) >= a.r + b.r) continue;
      
      const dx = b.x - a.x;
      const distSq = dx * dx + dy * dy;
      const radSum = a.r + b.r;
      
      if(distSq < radSum * radSum) {
        const dist = Math.sqrt(distSq);
        const overlap = (radSum - dist) * 0.5;
        const invDist = 1 / dist;
        const nx = dx * invDist;
        const ny = dy * invDist;
        
        a.x -= nx * overlap; a.y -= ny * overlap;
        b.x += nx * overlap; b.y += ny * overlap;
        
        const dvx = a.vx - b.vx;
        const dvy = a.vy - b.vy;
        const dvn = dvx * nx + dvy * ny;
        
        // Apply friction during collision - reduce energy
        let energyLoss = 1.0;
        if(frictionOn) {
          const relativeSpeed = Math.sqrt(dvx * dvx + dvy * dvy);
          energyLoss = 1.0 - (frictionAmount * relativeSpeed * 0.1);
          energyLoss = Math.max(0.1, energyLoss); // Don't completely stop
        }
        
        const impulse = dvn * energyLoss;
        a.vx -= impulse * nx; a.vy -= impulse * ny;
        b.vx += impulse * nx; b.vy += impulse * ny;
        
        collisionCount++;
      }
    }
  }
}

/* --- Fast Temperature Calculation --- */
function getTemperature(boxIndex) {
  let sumKE = 0, count = 0;
  const len = particles.length;
  
  if(boxIndex === 0) {
    for(let i = 0; i < len; i++) {
      const p = particles[i];
      if(p.x < leftBoxW) {
        sumKE += p.vx * p.vx + p.vy * p.vy;
        count++;
      }
    }
  } else {
    for(let i = 0; i < len; i++) {
      const p = particles[i];
      if(p.x > rightBoxX) {
        sumKE += p.vx * p.vx + p.vy * p.vy;
        count++;
      }
    }
  }
  
  return count ? sumKE / count : 0;
}

function tempToRMS(T) { 
  return Math.sqrt(T > 0 ? T : 0) * TEMP_SPEED_FACTOR; 
}

function setBoxTemperature(boxIndex, targetT) {
  let sumSq = 0, count = 0;
  const len = particles.length;
  
  // Calculate current RMS
  for(let i = 0; i < len; i++) {
    const p = particles[i];
    const inLeft = p.x < leftBoxW;
    if((boxIndex === 0 && inLeft) || (boxIndex === 1 && !inLeft)) {
      sumSq += p.vx * p.vx + p.vy * p.vy;
      count++;
    }
  }
  
  const currentRMS = count ? Math.sqrt(sumSq * 0.5 / count) : 0;
  const targetRMS = tempToRMS(targetT);
  const scale = currentRMS > 1e-6 ? targetRMS / currentRMS : 0;
  
  // Apply scaling
  for(let i = 0; i < len; i++) {
    const p = particles[i];
    const inLeft = p.x < leftBoxW;
    if((boxIndex === 0 && inLeft) || (boxIndex === 1 && !inLeft)) {
      if(scale === 0) {
        const angle = Math.random() * TWO_PI;
        p.vx = targetRMS * Math.cos(angle);
        p.vy = targetRMS * Math.sin(angle);
      } else {
        p.vx *= scale;
        p.vy *= scale;
      }
    }
  }
}

/* --- Hyper-Fast Drawing --- */
function draw() {
  ctx.clearRect(0, 0, canvasW, canvasH);
  
  // Draw wall once
  ctx.strokeStyle = "#fff";
  ctx.lineWidth = 3;
  ctx.beginPath();
  const pipeTop = (canvasH - pipeHeight) * 0.5;
  ctx.moveTo(leftBoxW, 0);
  ctx.lineTo(leftBoxW, pipeTop);
  ctx.moveTo(leftBoxW, pipeTop + pipeHeight);
  ctx.lineTo(leftBoxW, canvasH);
  ctx.stroke();
  
  // Draw all particles as single color circles
  ctx.fillStyle = '#ff4400';
  const len = particles.length;
  for(let i = 0; i < len; i++) {
    const p = particles[i];
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, TWO_PI);
    ctx.fill();
  }
}

/* --- Minimal Graph Updates --- */
let lastGraphUpdate = 0;
function updateGraphs(leftTemp, rightTemp, currentTime) {
  if(currentTime - lastGraphUpdate < 500) return; // Update even less frequently
  lastGraphUpdate = currentTime;
  
  leftTempHistory.push(leftTemp);
  rightTempHistory.push(rightTemp);
  
  if(leftTempHistory.length > maxGraphPoints) leftTempHistory.shift();
  if(rightTempHistory.length > maxGraphPoints) rightTempHistory.shift();
  
  // Simplified graph drawing
  if(leftTempHistory.length > 1) {
    leftGraph.clearRect(0, 0, 200, 100);
    leftGraph.strokeStyle = "#ffa";
    leftGraph.lineWidth = 2;
    leftGraph.beginPath();
    for(let i = 0; i < leftTempHistory.length; i++) {
      const x = (i / maxGraphPoints) * 200;
      const y = 100 - (leftTempHistory[i] / 600) * 100;
      if(i === 0) leftGraph.moveTo(x, y);
      else leftGraph.lineTo(x, y);
    }
    leftGraph.stroke();
  }
  
  if(rightTempHistory.length > 1) {
    rightGraph.clearRect(0, 0, 200, 100);
    rightGraph.strokeStyle = "#aaf";
    rightGraph.lineWidth = 2;
    rightGraph.beginPath();
    for(let i = 0; i < rightTempHistory.length; i++) {
      const x = (i / maxGraphPoints) * 200;
      const y = 100 - (rightTempHistory[i] / 600) * 100;
      if(i === 0) rightGraph.moveTo(x, y);
      else rightGraph.lineTo(x, y);
    }
    rightGraph.stroke();
  }
}

/* --- LUDICROUS SPEED Main Loop --- */
function step(currentTime) {
  if(!paused) {
    // Update particles - unrolled loop for speed
    const len = particles.length;
    for(let i = 0; i < len; i++) {
      particles[i].update();
    }
    
    // Only do collision detection every other frame for extreme speed
    if(frameCount % 2 === 0) {
      collisionDetection();
    }
  }
  
  draw();
  
  // Reduce UI update frequency
  if(frameCount % 10 === 0) {
    const leftT = getTemperature(0);
    const rightT = getTemperature(1);
    
    leftTempDisplay.textContent = leftT.toFixed(0);
    rightTempDisplay.textContent = rightT.toFixed(0);
    totalParticlesDisplay.textContent = particles.length;
    
    updateGraphs(leftT, rightT, currentTime);
  }
  
  frameCount++;
  if(currentTime - lastFpsTime > 1000) {
    fpsDisplay.textContent = frameCount;
    collisionRateDisplay.textContent = Math.floor((collisionCount - lastCollisionCount) * 2); // *2 because we skip every other frame
    lastCollisionCount = collisionCount;
    frameCount = 0;
    lastFpsTime = currentTime;
  }
  
  requestAnimationFrame(step);
}

/* --- Setup --- */
function createParticles() {
  particles.length = 0; // Clear array efficiently
  const n = parseInt(nRange.value);
  const r = parseInt(rRange.value);
  
  // Pre-allocate arrays
  particles = new Array(n * 2);
  let idx = 0;
  
  // Left box
  const leftW = leftBoxW - 2 * r;
  const boxH = canvasH - 2 * r;
  const leftSpeed = tempToRMS(parseFloat(tLRange.value));
  
  for(let i = 0; i < n; i++) {
    const angle = Math.random() * TWO_PI;
    const x = Math.random() * leftW + r;
    const y = Math.random() * boxH + r;
    particles[idx++] = new Particle(x, y, leftSpeed * Math.cos(angle), leftSpeed * Math.sin(angle), r);
  }
  
  // Right box
  const rightW = (canvasW - rightBoxX) - 2 * r;
  const rightSpeed = tempToRMS(parseFloat(tRRange.value));
  
  for(let i = 0; i < n; i++) {
    const angle = Math.random() * TWO_PI;
    const x = Math.random() * rightW + rightBoxX + r;
    const y = Math.random() * boxH + r;
    particles[idx++] = new Particle(x, y, rightSpeed * Math.cos(angle), rightSpeed * Math.sin(angle), r);
  }
  
  sortedParticles = new Array(particles.length);
  leftTempHistory.length = 0;
  rightTempHistory.length = 0;
  collisionCount = 0;
  lastCollisionCount = 0;
  frameCount = 0;
  lastFpsTime = 0;
}

/* --- Event Listeners --- */
nRange.oninput = () => nLabel.textContent = nRange.value;
tLRange.oninput = () => { 
  tLLabel.textContent = tLRange.value; 
  setBoxTemperature(0, Number(tLRange.value)); 
};
tRRange.oninput = () => { 
  tRLabel.textContent = tRRange.value; 
  setBoxTemperature(1, Number(tRRange.value)); 
};
rRange.oninput = () => rLabel.textContent = rRange.value;
pipeRange.oninput = () => { 
  pipeLabel.textContent = pipeRange.value; 
  pipeHeight = parseInt(pipeRange.value); 
};

gravityRange.oninput = () => {
  gravityLabel.textContent = gravityRange.value;
  gravityStrength = parseFloat(gravityRange.value);
};

frictionRange.oninput = () => {
  frictionLabel.textContent = frictionRange.value;
  frictionAmount = parseFloat(frictionRange.value);
};

resetBtn.onclick = createParticles;
pauseBtn.onclick = () => { 
  paused = !paused; 
  pauseBtn.textContent = paused ? 'Resume' : 'Pause'; 
};
openWallBtn.onclick = () => { 
  wallOpen = !wallOpen; 
  openWallBtn.textContent = wallOpen ? 'Close Pipe' : 'Open Pipe'; 
};

gravityBtn.onclick = () => {
  gravityOn = !gravityOn;
  gravityBtn.textContent = gravityOn ? 'Gravity: ON' : 'Gravity: OFF';
  gravityBtn.style.background = gravityOn ? '#060' : '#333';
};

frictionBtn.onclick = () => {
  frictionOn = !frictionOn;
  frictionBtn.textContent = frictionOn ? 'Friction: ON' : 'Friction: OFF';
  frictionBtn.style.background = frictionOn ? '#600' : '#333';
};

/* --- Initialize --- */
pipeHeight = parseInt(pipeRange.value);
gravityStrength = parseFloat(gravityRange.value);
frictionAmount = parseFloat(frictionRange.value);
createParticles();
requestAnimationFrame(step);
</script>
</body>
</html>