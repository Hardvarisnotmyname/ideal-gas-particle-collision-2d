<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Ultimate Ideal Gas Simulation (JIT-Optimized)</title>
  <meta name="viewport" content="width=1200, initial-scale=1.0">
  <style>
    body { background: #111; color: #fff; font-family: Arial, sans-serif; margin: 0; padding: 0;}
    .container { max-width: 1500px; margin: 0 auto;}
    .controls { display: flex; flex-wrap: wrap; gap: 20px; align-items: center; margin: 20px 0; }
    .controls label { font-size: 14px; }
    .controls input[type="range"] { width: 120px; }
    .stats, .temp-display { display: flex; gap: 24px; margin-bottom: 8px; }
    .canvas-row { display: flex; gap: 24px; }
    canvas { background: black; border: 2px solid #333; border-radius: 12px;}
    .btn { background: #333; color: #fff; border: none; border-radius: 5px; padding: 8px 20px; cursor: pointer; font-size: 14px;}
    .btn:hover { background: #555;}
    .graph-title { text-align: center; font-size: 13px; }
  </style>
</head>
<body>
<div class="container">
  <h1>Ultimate Ideal Gas Simulation <span style="font-size:16px;color:#0f0;">[JIT-Optimized]</span></h1>
  
  <div class="controls">
    <label>Particles/Box: <input id="nRange" type="range" min="10" max="70000" value="500"><span id="nLabel">500</span></label>
    <label>Temp Left: <input id="tLRange" type="range" min="0" max="1200" value="300"><span id="tLLabel">300</span></label>
    <label>Temp Right: <input id="tRRange" type="range" min="0" max="1200" value="100"><span id="tRLabel">100</span></label>
    <label>Radius: <input id="rRange" type="range" min="1" max="8" value="2"><span id="rLabel">2</span></label>
    <label>Pipe Height: <input id="pipeRange" type="range" min="30" max="600" value="100"><span id="pipeLabel">100</span></label>
    <button class="btn" id="resetBtn">Reset</button>
    <button class="btn" id="pauseBtn">Pause</button>
    <button class="btn" id="openWallBtn">Open Pipe</button>
  </div>
  
  <div class="temp-display">
    <div style="color:#ffa;">Left Temp: <span id="leftTemp">0</span></div>
    <div style="color:#aaf;">Right Temp: <span id="rightTemp">0</span></div>
  </div>
  <div class="stats">
    <div>Total Particles: <span id="totalParticles">0</span></div>
    <div>Collisions/sec: <span id="collisionRate">0</span></div>
    <div>FPS: <span id="fps">0</span></div>
  </div>
  
  <div class="canvas-row">
    <canvas id="simCanvas" width="1200" height="600"></canvas>
    <div>
      <div class="graph-title" style="color:#ffa;">Left Box Temperature</div>
      <canvas id="leftGraph" width="200" height="100"></canvas>
      <div class="graph-title" style="color:#aaf;">Right Box Temperature</div>
      <canvas id="rightGraph" width="200" height="100"></canvas>
    </div>
  </div>
</div>

<script>
/* --- UI Elements --- */
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const leftGraph = document.getElementById('leftGraph').getContext('2d');
const rightGraph = document.getElementById('rightGraph').getContext('2d');
const nRange = document.getElementById('nRange');
const tLRange = document.getElementById('tLRange');
const tRRange = document.getElementById('tRRange');
const rRange = document.getElementById('rRange');
const pipeRange = document.getElementById('pipeRange');
const nLabel = document.getElementById('nLabel');
const tLLabel = document.getElementById('tLLabel');
const tRLabel = document.getElementById('tRLabel');
const rLabel = document.getElementById('rLabel');
const pipeLabel = document.getElementById('pipeLabel');
const resetBtn = document.getElementById('resetBtn');
const pauseBtn = document.getElementById('pauseBtn');
const openWallBtn = document.getElementById('openWallBtn');
const leftTempDisplay = document.getElementById('leftTemp');
const rightTempDisplay = document.getElementById('rightTemp');
const totalParticlesDisplay = document.getElementById('totalParticles');
const collisionRateDisplay = document.getElementById('collisionRate');
const fpsDisplay = document.getElementById('fps');

/* --- Config/State --- */
let paused = false, wallOpen = false;
let particles = [];
let pipeHeight = parseInt(pipeRange.value);
let collisionCount = 0, lastCollisionCount = 0, frameCount = 0, lastFpsTime = 0;
let leftTempHistory = [], rightTempHistory = [];
const maxGraphPoints = 100;
const TEMP_SPEED_FACTOR = 0.025;
const leftBox = {x:0, y:0, w:canvas.width/2, h:canvas.height};
const rightBox = {x:canvas.width/2, y:0, w:canvas.width/2, h:canvas.height};
let grid;

/* --- Particle Class --- */
class Particle {
  constructor(x, y, vx, vy, r, id, m=1) {
    this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.r = r; this.id = id; this.m = m;
  }
  update() {
    this.x += this.vx; this.y += this.vy;
    if(this.x-this.r<0) { this.x=this.r; this.vx*=-1; }
    if(this.x+this.r>canvas.width) { this.x=canvas.width-this.r; this.vx*=-1; }
    if(this.y-this.r<0) { this.y=this.r; this.vy*=-1; }
    if(this.y+this.r>canvas.height) { this.y=canvas.height-this.r; this.vy*=-1; }
    if(this.x+this.r>leftBox.w && this.x-this.r<leftBox.w) {
      const withinPipe = (this.y>(canvas.height-pipeHeight)/2 && this.y<(canvas.height+pipeHeight)/2);
      if(!wallOpen || !withinPipe) {
        if(this.vx > 0) { this.x=leftBox.w-this.r; } else { this.x=leftBox.w+this.r; }
        this.vx *= -1;
      }
    }
  }
  draw() {
    const speed = Math.hypot(this.vx, this.vy);
    const hue = 240-Math.min(speed*150, 240);
    ctx.fillStyle = `hsl(${hue},100%,50%)`;
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.r,0,2*Math.PI);
    ctx.fill();
  }
}

/* --- Final Spatial Hash Grid (Integer Keys) --- */
class SpatialHashGrid {
  constructor(bounds, cellSize) {
    this.cellSize = cellSize;
    this.cols = Math.ceil(bounds.w / cellSize);
    this.cells = new Map();
  }
  getKey(x, y) {
    // Return a single integer key, which is much faster than a string.
    return Math.floor(x / this.cellSize) + Math.floor(y / this.cellSize) * this.cols;
  }
  clear() {
    this.cells.clear();
  }
  insert(particle) {
    const key = this.getKey(particle.x, particle.y);
    if (!this.cells.has(key)) {
      this.cells.set(key, []);
    }
    this.cells.get(key).push(particle);
  }
}

function resolveCollision(p1, p2) {
    const totalRadius = p1.r + p2.r;
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;

    if (Math.abs(dx) > totalRadius || Math.abs(dy) > totalRadius) return;
    
    const distanceSq = dx * dx + dy * dy;
    if (distanceSq > totalRadius * totalRadius) return;

    const dist = Math.sqrt(distanceSq);
    const overlap = 0.5 * (totalRadius - dist);
    const nx = dx / dist, ny = dy / dist;
    
    p1.x -= nx * overlap; p1.y -= ny * overlap;
    p2.x += nx * overlap; p2.y += ny * overlap;

    const kx = p1.vx - p2.vx, ky = p1.vy - p2.vy;
    const p = 2 * (nx * kx + ny * ky) / (p1.m + p2.m);
    p1.vx -= p * p2.m * nx; p1.vy -= p * p2.m * ny;
    p2.vx += p * p1.m * nx; p2.vy += p * p1.m * ny;
    
    collisionCount++;
}

function checkCollisions() {
    grid.clear();
    for (const p of particles) grid.insert(p);

    const gridCols = grid.cols;
    for (const [key, cellParticles] of grid.cells) {
        // Intra-cell collisions
        for (let i = 0; i < cellParticles.length; i++) {
            for (let j = i + 1; j < cellParticles.length; j++) {
                resolveCollision(cellParticles[i], cellParticles[j]);
            }
        }
        
        // Inter-cell collisions with numeric keys. No string parsing, no new arrays.
        const neighborKeys = [key + 1, key - 1 + gridCols, key + gridCols, key + 1 + gridCols];
        for (const neighborKey of neighborKeys) {
            if (grid.cells.has(neighborKey)) {
                for (const p1 of cellParticles) {
                    for (const p2 of grid.cells.get(neighborKey)) {
                        resolveCollision(p1, p2);
                    }
                }
            }
        }
    }
}

/* --- Temperature/Stats --- */
function getTemperature(boxIndex) {
  let sumKE=0, count=0;
  for(let p of particles) {
    if((boxIndex===0 && p.x<leftBox.w)||(boxIndex===1 && p.x>rightBox.x)) {
      sumKE += 0.5*p.m*(p.vx*p.vx+p.vy*p.vy); count++;
    }
  }
  return count > 1 ? (2*sumKE)/(2*count) : 0; // Corrected KE formula
}
function tempToRMS(T) { return Math.sqrt(Math.max(0,T)) * TEMP_SPEED_FACTOR; }
function setBoxTemperature(boxIndex, targetT) {
    let sumSq = 0, count = 0;
    for (let p of particles) {
        const inLeft = p.x < leftBox.w;
        if ((boxIndex === 0 && inLeft) || (boxIndex === 1 && !inLeft)) {
            sumSq += p.vx * p.vx + p.vy * p.vy; count++;
        }
    }
    const currentRMS = count ? Math.sqrt(sumSq/count) : 0;
    const targetRMS = tempToRMS(targetT);
    const scale = (currentRMS > 1e-6) ? targetRMS / currentRMS : 0;

    for (let p of particles) {
        const inLeft = p.x < leftBox.w;
        if ((boxIndex === 0 && inLeft) || (boxIndex === 1 && !inLeft)) {
            if (scale === 0) {
                const angle = Math.random() * 2 * Math.PI;
                p.vx = targetRMS * Math.cos(angle); p.vy = targetRMS * Math.sin(angle);
            } else {
                p.vx *= scale; p.vy *= scale;
            }
        }
    }
}

/* --- Graphing --- */
function drawGraph(ctx, data, color) {
    const width = ctx.canvas.width, height = ctx.canvas.height;
    ctx.clearRect(0,0,width,height);
    if (data.length < 2) return;
    let min = data[0], max = data[0];
    for (let i = 1; i < data.length; i++) {
        if (data[i] < min) min = data[i];
        if (data[i] > max) max = data[i];
    }
    if (min === max) max = min + 1;
    const range = max-min;
    const yMin = Math.max(0, min - 0.1 * range), yMax = max + 0.1 * range;
    const finalRange = yMax - yMin;
    ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.beginPath();
    for (let i = 0; i < data.length; i++) {
        const x = (i / (maxGraphPoints - 1)) * width;
        const y = height - ((data[i] - yMin) / finalRange) * height;
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();
}

let lastGraphUpdate = 0;
function updateGraphs(leftTemp, rightTemp, currentTime) {
    if (currentTime - lastGraphUpdate < 250) return;
    lastGraphUpdate = currentTime;
    leftTempHistory.push(leftTemp);
    rightTempHistory.push(rightTemp);
    if(leftTempHistory.length > maxGraphPoints) leftTempHistory.shift();
    if(rightTempHistory.length > maxGraphPoints) rightTempHistory.shift();
    drawGraph(leftGraph, leftTempHistory, "#ffa");
    drawGraph(rightGraph, rightTempHistory, "#aaf");
}

/* --- Main Loop --- */
function step(currentTime) {
  if(!paused) {
    for(let p of particles) p.update();
    checkCollisions();
  }
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.strokeStyle="#fff"; ctx.lineWidth=3;
  const pipeTop = (canvas.height-pipeHeight)/2;
  ctx.beginPath();
  ctx.moveTo(leftBox.w,0); ctx.lineTo(leftBox.w, pipeTop);
  ctx.moveTo(leftBox.w, pipeTop + pipeHeight); ctx.lineTo(leftBox.w,canvas.height);
  ctx.stroke();
  for(let p of particles) p.draw();
  const leftT = getTemperature(0), rightT = getTemperature(1);
  leftTempDisplay.textContent = leftT.toFixed(1);
  rightTempDisplay.textContent = rightT.toFixed(1);
  totalParticlesDisplay.textContent = particles.length;
  updateGraphs(leftT, rightT, currentTime);
  frameCount++;
  if(currentTime-lastFpsTime > 1000) {
    fpsDisplay.textContent = frameCount;
    collisionRateDisplay.textContent = collisionCount - lastCollisionCount;
    lastCollisionCount = collisionCount;
    frameCount=0; lastFpsTime=currentTime;
  }
  requestAnimationFrame(step);
}

/* --- Setup/Reset --- */
function createParticles() {
  particles=[];
  const n = parseInt(nRange.value);
  const r = parseInt(rRange.value);
  grid = new SpatialHashGrid({x:0, y:0, w:canvas.width, h:canvas.height}, r * 2);
  let particleIdCounter = 0;
  for(let i=0;i<n;i++) {
    const speed = tempToRMS(parseFloat(tLRange.value));
    const angle = Math.random()*2*Math.PI;
    const x = Math.random()*(leftBox.w-2*r)+r;
    const y = Math.random()*(leftBox.h-2*r)+r;
    particles.push(new Particle(x,y,speed*Math.cos(angle),speed*Math.sin(angle),r, particleIdCounter++));
  }
  for(let i=0;i<n;i++) {
    const speed = tempToRMS(parseFloat(tRRange.value));
    const angle = Math.random()*2*Math.PI;
    const x = Math.random()*(rightBox.w-2*r)+rightBox.x+r;
    const y = Math.random()*(rightBox.h-2*r)+r;
    particles.push(new Particle(x,y,speed*Math.cos(angle),speed*Math.sin(angle),r, particleIdCounter++));
  }
  leftTempHistory=[]; rightTempHistory=[];
  collisionCount=0; lastCollisionCount=0; frameCount=0; lastFpsTime=0;
}

/* --- Event Listeners --- */
nRange.oninput = ()=>{ nLabel.textContent = nRange.value; };
tLRange.oninput = ()=>{ tLLabel.textContent = tLRange.value; setBoxTemperature(0,Number(tLRange.value)); };
tRRange.oninput = ()=>{ tRLabel.textContent = tRRange.value; setBoxTemperature(1,Number(tRRange.value)); };
rRange.oninput = ()=>{ rLabel.textContent = rRange.value; };
pipeRange.oninput = ()=>{ pipeLabel.textContent = pipeRange.value; pipeHeight=parseInt(pipeRange.value); };
resetBtn.onclick = ()=>{ createParticles(); };
pauseBtn.onclick = ()=>{ paused=!paused; pauseBtn.textContent=paused?'Resume':'Pause'; };
openWallBtn.onclick = ()=>{ wallOpen=!wallOpen; openWallBtn.textContent=wallOpen?'Close Pipe':'Open Pipe'; };

/* --- Init --- */
createParticles();
requestAnimationFrame(step);
</script>
</body>
</html>